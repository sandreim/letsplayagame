import{W as u,A as g,w as y,a as p,c as f,K as M,b as I}from"./polkadot-2dd106b8.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))a(n);new MutationObserver(n=>{for(const i of n)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&a(o)}).observe(document,{childList:!0,subtree:!0});function t(n){const i={};return n.integrity&&(i.integrity=n.integrity),n.referrerPolicy&&(i.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?i.credentials="include":n.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function a(n){if(n.ep)return;n.ep=!0;const i=t(n);fetch(n.href,i)}})();class b{constructor(){this.api=null,this.unsubscribeBlocks=null,this.unsubscribeFinalizedBlocks=null,this.blockWindow=[],this.maxBlocksInWindow=50,this.finalizedBlockNumber=0,this.blockTimestamps=new Map,this.onBlockCallback=null}async connect(e){this.api&&(await this.api.disconnect(),this.stopBlockSubscription());const t=new u(e),a={Cell:{_enum:["Empty","X","O"]},GameState:{_enum:["InProgress","XWon","OWon","Draw"]},Game:{player_x:"AccountId",player_o:"AccountId",x_turn:"bool",board:"[Cell; 9]",state:"GameState"}};return this.api=await g.create({provider:t,noInitWarn:!0,types:a}),await this.api.isReady,this.api}async callRuntimeAPI(e,t,a=[]){if(!this.api)throw new Error("API not connected");const n=`${e}_${t}`;console.log(`Calling runtime API: ${n}`),console.log("Params:",a.map(s=>({value:s.toString(),hex:s.toHex(),u8a:Array.from(s.toU8a())})));let i="0x";if(a.length>0){const s=[];a.forEach(r=>{const l=r.toU8a();s.push(...l)}),i=this.api.createType("Bytes",s).toHex()}console.log("Encoded params (hex):",i);const o=await this.api.rpc.state.call(n,i);return console.log("Raw result:",o.toHex()),o}async disconnect(){this.api&&(await this.api.disconnect(),this.api=null),this.stopBlockSubscription()}async getChainInfo(){if(!this.api)throw new Error("Not connected to chain");const[e,t]=await Promise.all([this.api.rpc.system.chain(),this.api.rpc.system.version()]);return{chain:e.toString(),version:t.toString()}}subscribeToBlocks(e){this.api&&(this.onBlockCallback=e,this.unsubscribeBlocks=this.api.rpc.chain.subscribeNewHeads(t=>{this.updateBlockInfo(t),e&&e()}),this.unsubscribeFinalizedBlocks=this.api.rpc.chain.subscribeFinalizedHeads(t=>{this.updateFinalizedBlockInfo(t)}))}updateBlockInfo(e){const t=e.number.toNumber(),a=e.hash.toString(),n=Date.now();this.blockTimestamps.set(t,n),this.addBlockToWindow(t,a,!1)}updateFinalizedBlockInfo(e){const t=e.number.toNumber();this.finalizedBlockNumber=t,this.markFinalizedBlocks()}addBlockToWindow(e,t,a){if(this.blockWindow.findIndex(s=>s.number===e)!==-1)return;const i={number:e,hash:t,isFinalized:a||e<=this.finalizedBlockNumber};this.blockWindow.push(i),this.blockWindow.sort((s,r)=>r.number-s.number);const o=document.getElementById("blockWindow");if(o){const s=o.offsetWidth,m=Math.floor(s/(42+4));if(this.blockWindow.length>m){this.blockWindow=this.blockWindow.slice(0,m);const d=new Set(this.blockWindow.map(h=>h.number));for(const[h]of this.blockTimestamps)d.has(h)||this.blockTimestamps.delete(h)}}this.renderBlockWindow()}markFinalizedBlocks(){this.blockWindow.forEach(e=>{e.number<=this.finalizedBlockNumber&&(e.isFinalized=!0)}),this.renderBlockWindow()}renderBlockWindow(){const e=document.getElementById("blockWindow"),t=document.getElementById("blockTimeline");!e||!t||(e.innerHTML="",this.blockWindow.forEach((a,n)=>{const i=document.createElement("div");i.className="block-item",a.isFinalized&&i.classList.add("finalized"),n===0&&i.classList.add("new-block");const o=`${a.hash.slice(2,6)}${a.hash.slice(-2)}`;i.innerHTML=`
                <div class="block-number">${a.number}</div>
                <div class="block-hash-short">${o}</div>
            `;const s=this.blockTimestamps.get(a.number),r=s?new Date(s).toLocaleTimeString():"";i.title=`Block #${a.number.toLocaleString()}
${a.hash}
${r}
${a.isFinalized?"✓ Finalized":"Pending"}`,e.appendChild(i)}),t.innerHTML="",this.blockWindow.forEach((a,n)=>{const i=document.createElement("div");i.className="timeline-tick";const o=this.blockTimestamps.get(a.number);let s="--";if(o&&n<this.blockWindow.length-1){const r=this.blockWindow[n+1],l=this.blockTimestamps.get(r.number);if(l){const d=((o-l)/1e3).toFixed(1);s=`${d}s`,parseFloat(d)>=10&&i.classList.add("major")}}i.innerHTML=`
                <div class="tick-mark"></div>
                <div class="tick-time">${s}</div>
            `,t.appendChild(i)}))}stopBlockSubscription(){this.unsubscribeBlocks&&(this.unsubscribeBlocks(),this.unsubscribeBlocks=null),this.unsubscribeFinalizedBlocks&&(this.unsubscribeFinalizedBlocks(),this.unsubscribeFinalizedBlocks=null)}isConnected(){return this.api!==null&&this.api.isConnected}}class B{constructor(e){this.chainManager=e,this.currentAccount=null,this.keyring=null,this.keyringPair=null,this.accountType=null,this.accountUpdateInterval=null,this.lastAccountUpdate=0,this.accountUpdateThrottle=3e3}async connectWallet(){try{if((await y("Polkadot Tic-Tac-Toe")).length===0)throw new Error("No extension installed. Please install Polkadot.js extension.");const t=await p();if(t.length===0)throw new Error("No accounts found. Please create an account in your Polkadot.js extension.");return this.currentAccount=t[0],this.accountType="extension",this.currentAccount}catch(e){throw console.error("Error connecting wallet:",e),e}}async createFromSeed(e){try{return await f(),this.keyring||(this.keyring=new M({type:"sr25519"})),this.keyringPair=this.keyring.addFromUri(e),this.currentAccount={address:this.keyringPair.address,meta:{name:"Seed Account",source:"seed"}},this.accountType="seed",this.currentAccount}catch(t){throw console.error("Error creating account from seed:",t),t}}async getBalance(){if(!this.currentAccount||!this.chainManager.api)return null;const{data:e}=await this.chainManager.api.query.system.account(this.currentAccount.address),t=this.chainManager.api.registry.chainDecimals[0]||12,a=Math.pow(10,t),n=i=>(parseFloat(i.toString())/a).toFixed(4);return{free:n(e.free),reserved:n(e.reserved),frozen:n(e.frozen)}}startBalanceUpdates(e){this.accountUpdateInterval=setInterval(async()=>{const t=Date.now();if(t-this.lastAccountUpdate>=this.accountUpdateThrottle){this.lastAccountUpdate=t;try{const a=await this.getBalance();e(a)}catch(a){console.error("Error updating balance:",a)}}},this.accountUpdateThrottle)}stopBalanceUpdates(){this.accountUpdateInterval&&(clearInterval(this.accountUpdateInterval),this.accountUpdateInterval=null)}async signAndSend(e,t){if(this.accountType==="seed")return await e.signAndSend(this.keyringPair,t);{const a=await I(this.currentAccount.address);return await e.signAndSend(this.currentAccount.address,{signer:a.signer},t)}}async sendUnsigned(e,t){return await e.send(t)}disconnect(){this.stopBalanceUpdates(),this.currentAccount=null,this.accountType=null,this.keyringPair=null}isConnected(){return this.currentAccount!==null}getAddress(){return this.currentAccount?.address||null}}class S{constructor(e,t){this.chainManager=e,this.accountManager=t,this.gameId=null,this.isActive=!1,this.board=Array(9).fill(null),this.playerSymbol=null,this.opponentAddress=null,this.playerX=null,this.playerO=null,this.isMyTurn=!1,this.isEnded=!1,this.gameState=null,this.onStateChangeCallbacks=[]}onStateChange(e){this.onStateChangeCallbacks.push(e)}notifyStateChange(){console.log(`🔔 notifyStateChange called. Callbacks: ${this.onStateChangeCallbacks.length}`),console.log("   State:",{gameId:this.gameId,isMyTurn:this.isMyTurn,playerSymbol:this.playerSymbol,isActive:this.isActive,isEnded:this.isEnded}),this.onStateChangeCallbacks.forEach((e,t)=>{try{console.log(`  Calling callback #${t}`),e(this)}catch(a){console.error(`Error in state change callback #${t}:`,a)}})}initialize(e,t,a){const n=this.accountManager.getAddress();if(n!==t&&n!==a)throw new Error("You are not a player in this game");this.gameId=e,this.playerX=t,this.playerO=a,this.playerSymbol=n===t?"X":"O",this.opponentAddress=n===t?a:t,this.isActive=!0,console.log(`Game ${e} initialized. You are Player ${this.playerSymbol}`)}async getPlayerGame(){if(!this.chainManager.api||!this.accountManager.isConnected())return null;try{const e=this.accountManager.getAddress();console.log("Fetching active game for player:",e);const t=this.chainManager.api,a=t.createType("AccountId32",e),n=await this.chainManager.callRuntimeAPI("TicTacToeApi","get_player_game",[a]),i=t.createType("Option<(u32, Game)>",n);if(i.isNone)return console.log("No active game found"),null;const[o,s]=i.unwrap();return console.log(`Found active game #${o.toNumber()}`),[o.toNumber(),s]}catch(e){throw console.error("Error fetching player game:",e),e}}async refresh(){if(!this.chainManager.api)return console.warn("Cannot refresh: API not ready"),!1;try{console.log("Refreshing game state from chain...");const e=await this.getPlayerGame();if(!e)return console.log("No active game found for player"),this.gameId!==null&&(console.log("Previous game has ended"),this.isActive=!1,this.isEnded=!0),!1;const[t,a]=e;console.log(`Refreshing game #${t} from chain:`,a.toHuman()),this.gameId!==t&&(console.log(`Game ID changed from ${this.gameId} to ${t}, re-initializing`),this.initialize(t,a.player_x.toString(),a.player_o.toString())),this.updateBoard(a.board);const n=a.x_turn!==void 0?a.x_turn:a.xTurn,i=this.isMyTurn;console.log("🔄 Turn data from chain:",{"gameData.x_turn":a.x_turn,"gameData.xTurn":a.xTurn,"resolved xTurn":n,"xTurn type":typeof n,"xTurn.valueOf()":n?.valueOf?n.valueOf():n,playerSymbol:this.playerSymbol,oldIsMyTurn:i});const o=n?.valueOf?n.valueOf():!!n;this.isMyTurn=this.playerSymbol==="X"&&o||this.playerSymbol==="O"&&!o,console.log("Turn calculation result:",{xTurnBool:o,playerSymbol:this.playerSymbol,oldIsMyTurn:i,newIsMyTurn:this.isMyTurn,"newIsMyTurn type":typeof this.isMyTurn,changed:i!==this.isMyTurn});const s=a.state;return this.gameState=s,s.isInProgress||(this.isActive=!1,this.isEnded=!0,console.log("Game has ended:",s.toHuman())),console.log(`✓ Refreshed game #${this.gameId}:`,{board:this.board,isMyTurn:this.isMyTurn,isEnded:this.isEnded,state:this.gameState?.toHuman()}),this.notifyStateChange(),!0}catch(e){return console.error("Error refreshing game state:",e),!1}}updateBoard(e){const t=Array(9).fill(null);e.forEach((a,n)=>{const i=this.decodeCellValue(a);i&&(t[n]=i)}),this.board=t,console.log("Board updated:",t)}decodeCellValue(e){return e.isX||e.toHuman?.()==="X"||e.toJSON?.()==="X"?"X":e.isO||e.toHuman?.()==="O"||e.toJSON?.()==="O"?"O":null}async handleEvent(e,t){switch(console.log(`🎮 GameState handling event: ${e}`,t),e){case"gameCreated":const a=this.accountManager.getAddress();(t.playerX===a||t.playerO===a)&&(console.log("New game created for us, refreshing state..."),await this.refresh());break;case"moveMade":console.log("Move made, refreshing state..."),await this.refresh();break;case"gameEnded":console.log("Game ended, marking as inactive"),this.isActive=!1,this.isEnded=!0,this.notifyStateChange();break}}reset(){this.gameId=null,this.isActive=!1,this.board=Array(9).fill(null),this.playerSymbol=null,this.opponentAddress=null,this.playerX=null,this.playerO=null,this.isMyTurn=!1,this.isEnded=!1,this.gameState=null,console.log("Game state reset"),this.notifyStateChange()}toJSON(){return{gameId:this.gameId,isActive:this.isActive,isEnded:this.isEnded,board:this.board,playerSymbol:this.playerSymbol,opponentAddress:this.opponentAddress,playerX:this.playerX,playerO:this.playerO,isMyTurn:this.isMyTurn,gameState:this.gameState?.toHuman?.()||this.gameState}}}class T{constructor(e,t){this.chainManager=e,this.accountManager=t,this.gameState=new S(e,t),this.eventsSubscribed=!1,this.gameStats={xWins:0,oWins:0,draws:0},this.loadGameStats()}async getPlayerGame(){return await this.gameState.getPlayerGame()}async setupGame(e,t,a,n=null){try{if(console.log("setupGame called with:",{gameId:e,playerX:t,playerO:a,hasExistingData:!!n}),this.gameState.initialize(e,t,a),await this.gameState.refresh(),console.log("✓ Game setup complete:",this.gameState.toJSON()),this.gameState.isEnded){const i=this.gameState.gameState,o=i.toHuman();if(o==="XWon"||i.isXWon)return{ended:!0,state:1};if(o==="OWon"||i.isOWon)return{ended:!0,state:2};if(o==="Draw"||i.isDraw)return{ended:!0,state:3}}return{ended:!1}}catch(i){throw console.error("Error setting up game:",i),i}}async makeMove(e){if(!this.chainManager.api||!this.accountManager.isConnected())throw new Error("Not connected to chain or wallet");return console.log(`Making on-chain move: game ${this.gameState.gameId}, position ${e}`),this.chainManager.api.tx.ticTacToe.makeMove(this.gameState.gameId,e)}async claimTimeout(){if(!this.chainManager.api||!this.accountManager.isConnected())throw new Error("Not connected to chain or wallet");if(this.gameState.gameId===null||this.gameState.gameId===void 0)throw new Error("No active game");return console.log(`Claiming timeout victory for game ${this.gameState.gameId}`),this.chainManager.api.tx.ticTacToe.claimTimeout(this.gameState.gameId)}handleGameEnd(e){this.gameState.isActive=!1,this.gameState.isEnded=!0;let t="",a=null;switch(e){case 1:t="🎉 Player X wins!",a="winner",this.gameState.playerSymbol==="X"&&this.gameStats.xWins++;break;case 2:t="🎉 Player O wins!",a="winner",this.gameState.playerSymbol==="O"&&this.gameStats.oWins++;break;case 3:t="🤝 It's a draw!",a="draw",this.gameStats.draws++;break}return this.saveGameStats(),this.gameState.notifyStateChange(),{message:t,winnerType:a,stats:this.gameStats}}resetGame(){this.gameState.reset()}subscribeToGameEvents(e){if(this.eventsSubscribed||!this.chainManager.api){console.log("Events already subscribed or API not ready");return}console.log("Subscribing to game events..."),this.eventsSubscribed=!0,this.chainManager.api.query.system.events(async t=>{for(const{event:a}of t)if(this.chainManager.api.events.ticTacToe.MoveMade.is(a)){const[n,i,o]=a.data;n.toNumber()===this.gameState.gameId&&(console.log(`Move made in game ${n} by ${i} at position ${o}`),e("moveMade",{gameId:n.toNumber()}))}t.forEach(({event:a})=>{if(this.chainManager.api.events.ticTacToe.GameCreated.is(a)){const[n,i,o]=a.data;e("gameCreated",{gameId:n.toNumber(),playerX:i.toString(),playerO:o.toString()})}if(this.chainManager.api.events.ticTacToe.GameEnded.is(a)){const[n,i]=a.data;n.toNumber()===this.gameState.gameId&&(console.log(`Current game ${n} ended with state: ${i}`),e("gameEnded",{gameId:n.toNumber(),state:i.toNumber()}))}})})}saveGameStats(){localStorage.setItem("tictactoe_stats",JSON.stringify(this.gameStats))}loadGameStats(){const e=localStorage.getItem("tictactoe_stats");if(e)try{this.gameStats=JSON.parse(e)}catch(t){console.error("Error loading game stats:",t)}}getGameInfo(){return{currentGameId:this.gameState.gameId,currentPlayerSymbol:this.gameState.playerSymbol,opponentAddress:this.gameState.opponentAddress,gameActive:this.gameState.isActive,gameBoard:this.gameState.board,gameStats:this.gameStats}}}class v{constructor(e,t){this.chainManager=e,this.accountManager=t,this.inQueue=!1}async joinQueue(){if(!this.chainManager.api||!this.accountManager.isConnected())throw new Error("Not connected to chain or wallet");return console.log("Joining matchmaking queue..."),this.inQueue=!0,this.chainManager.api.tx.ticTacToe.playGame()}async cancelQueue(){if(!this.chainManager.api||!this.accountManager.isConnected())throw new Error("Not connected to chain or wallet");return console.log("Canceling matchmaking..."),this.inQueue=!1,this.chainManager.api.tx.ticTacToe.cancelMatchmaking()}isInQueue(){return this.inQueue}setInQueue(e){this.inQueue=e}}class w{constructor(){this.transactionHistory=[],this.pendingTransactions=new Map,this.timingChart=null}createTransaction(e,t,a,n){return{id:`${e}_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,from:t,to:a,amount:n,status:"pending",statusText:"Signing...",hash:null,blockHash:null,timing:{submitted:Date.now(),ready:null,broadcast:null,inBlock:null,finalized:null,invalid:null}}}addToHistory(e){return this.transactionHistory.unshift(e),this.transactionHistory.length>50&&(this.transactionHistory=this.transactionHistory.slice(0,50)),e.status==="pending"&&e.hash&&this.pendingTransactions.set(e.hash,e),this.transactionHistory}updateInHistory(e,t){const a=this.transactionHistory.find(n=>n.hash===e||n.id===e);return a&&(Object.assign(a,t),t.status!=="pending"&&a.hash&&this.pendingTransactions.delete(a.hash)),this.transactionHistory}clearHistory(){this.transactionHistory=[],this.pendingTransactions.clear()}getHistory(){return this.transactionHistory}getPendingCount(){return this.pendingTransactions.size}calculateStats(){console.log("Calculating stats from",this.transactionHistory.length,"total transactions");const e=[],t=[],a=[];if(this.transactionHistory.forEach(s=>{s.timing.ready&&e.push(s.timing.ready-s.timing.submitted),s.timing.inBlock&&t.push(s.timing.inBlock-s.timing.submitted),s.timing.finalized&&a.push(s.timing.finalized-s.timing.submitted)}),console.log("Stats data:",{ready:e.length,inBlock:t.length,finalized:a.length}),e.length===0&&t.length===0&&a.length===0)return console.log("No timing data available for stats"),null;const n=s=>s.length>0?s.reduce((r,l)=>r+l,0)/s.length:0,i=s=>s.length>0?Math.min(...s):0,o=s=>s.length>0?Math.max(...s):0;return{ready:{min:i(e),max:o(e),avg:n(e),count:e.length},inBlock:{min:i(t),max:o(t),avg:n(t),count:t.length},finalized:{min:i(a),max:o(a),avg:n(a),count:a.length}}}}class k{constructor(e){this.gameManager=e,this.elements=this.cacheElements(),this.gameManager.gameState.onStateChange(t=>{this.updateGameUI(t)})}updateGameUI(e){if(console.log("🎨 updateGameUI called with state:",e.toJSON()),e.gameId===null||e.gameId===void 0){console.log("No game ID, skipping UI update");return}this.updateBoardFromState(e),this.updatePlayerTurnFromState(e),console.log("✅ UI update complete")}updateBoardFromState(e){const t=e.board;console.log("Updating board from state:",t),t.forEach((a,n)=>{const i=document.querySelector(`[data-cell="${n}"]`);if(!i){console.error(`Cell element not found for index ${n}`);return}i.textContent="",i.classList.remove("taken","x","o"),a==="X"?(i.textContent="X",i.classList.add("taken","x")):a==="O"&&(i.textContent="O",i.classList.add("taken","o"))})}updatePlayerTurnFromState(e){console.log("📝 updatePlayerTurnFromState called with:",{playerSymbol:e.playerSymbol,isMyTurn:e.isMyTurn,isActive:e.isActive,isEnded:e.isEnded});const t=this.elements.currentPlayer;if(!t){console.error("❌ Player indicator element not found!");return}if(!e.playerSymbol){console.warn("⚠️ Player symbol not set");return}e.isEnded===!0?t.textContent="Game over":t.textContent=e.isMyTurn?`You are ${e.playerSymbol} - Your turn!`:`You are ${e.playerSymbol} - Opponent's turn...`,t.className=`player-indicator player-${e.playerSymbol.toLowerCase()}`,console.log("✅ Player turn updated successfully")}cacheElements(){return{rpcUrl:document.getElementById("rpcUrl"),connectBtn:document.getElementById("connectBtn"),connectionStatus:document.getElementById("connectionStatus"),statusIndicator:document.getElementById("statusIndicator"),statusText:document.getElementById("statusText"),chainInfo:document.getElementById("chainInfo"),chainName:document.getElementById("chainName"),chainVersion:document.getElementById("chainVersion"),connectWalletBtn:document.getElementById("connectWalletBtn"),useSeedBtn:document.getElementById("useSeedBtn"),seedInput:document.getElementById("seedInput"),seedPhrase:document.getElementById("seedPhrase"),importSeedBtn:document.getElementById("importSeedBtn"),cancelSeedBtn:document.getElementById("cancelSeedBtn"),accountType:document.getElementById("accountType"),accountInfo:document.getElementById("accountInfo"),accountAddress:document.getElementById("accountAddress"),accountBalance:document.getElementById("accountBalance"),playGameBtn:document.getElementById("playGameBtn"),cancelMatchmakingBtn:document.getElementById("cancelMatchmakingBtn"),matchmakingStatus:document.getElementById("matchmakingStatus"),gameBoard:document.getElementById("gameBoard"),gameBoardContainer:document.getElementById("gameBoardContainer"),gameModeSection:document.getElementById("gameModeSection"),gameIdDisplay:document.getElementById("gameIdDisplay"),gameIdValue:document.getElementById("gameIdValue"),playerXAddress:document.getElementById("playerXAddress"),playerOAddress:document.getElementById("playerOAddress"),gameInfoSection:document.getElementById("gameInfoSection"),currentPlayer:document.getElementById("currentPlayer"),gameMessage:document.getElementById("gameMessage"),resetGameBtn:document.getElementById("resetGameBtn"),gameStatsBottom:document.getElementById("gameStatsBottom"),xWins:document.getElementById("xWins"),oWins:document.getElementById("oWins"),draws:document.getElementById("draws"),timeoutSection:document.getElementById("timeoutSection"),timeoutTimer:document.getElementById("timeoutTimer"),timeoutCountdown:document.getElementById("timeoutCountdown"),claimTimeoutBtn:document.getElementById("claimTimeoutBtn"),gameWaitingOverlay:document.getElementById("gameWaitingOverlay"),transactionHistory:document.getElementById("transactionHistory"),clearHistoryBtn:document.getElementById("clearHistoryBtn"),pendingCount:document.getElementById("pendingCount"),timingChart:document.getElementById("timingChart"),statsContent:document.getElementById("statsContent"),minReady:document.getElementById("minReady"),maxReady:document.getElementById("maxReady"),avgReady:document.getElementById("avgReady"),minInBlock:document.getElementById("minInBlock"),maxInBlock:document.getElementById("maxInBlock"),avgInBlock:document.getElementById("avgInBlock"),minFinalized:document.getElementById("minFinalized"),maxFinalized:document.getElementById("maxFinalized"),avgFinalized:document.getElementById("avgFinalized"),blockBanner:document.getElementById("blockBanner"),blockWindow:document.getElementById("blockWindow")}}updateConnectionStatus(e,t){this.elements.statusText.textContent=t,e?this.elements.statusIndicator.classList.add("connected"):this.elements.statusIndicator.classList.remove("connected")}showChainInfo(e,t){this.elements.chainName.textContent=e,this.elements.chainVersion.textContent=t,this.elements.chainInfo.classList.remove("hidden")}hideChainInfo(){this.elements.chainInfo.classList.add("hidden")}showSeedInput(){this.elements.seedInput.classList.remove("hidden")}hideSeedInput(){this.elements.seedInput.classList.add("hidden"),this.elements.seedPhrase.value=""}updateAccountInfo(e,t){this.elements.accountAddress.textContent=e,this.elements.accountType.textContent=t==="seed"?"🔑 Seed Account":"🦊 Extension Account",this.elements.accountInfo.classList.remove("hidden")}updateBalance(e){this.elements.accountBalance.textContent=`Balance: ${e.free} UNIT`}hideAccountInfo(){this.elements.accountInfo.classList.add("hidden")}showMatchmakingWaiting(){this.elements.playGameBtn.classList.add("hidden"),this.elements.cancelMatchmakingBtn.classList.remove("hidden"),this.elements.matchmakingStatus.classList.remove("hidden")}hideMatchmakingWaiting(){this.elements.playGameBtn.classList.remove("hidden"),this.elements.playGameBtn.disabled=!1,this.elements.playGameBtn.textContent="START GAME",this.elements.cancelMatchmakingBtn.classList.add("hidden"),this.elements.matchmakingStatus.classList.add("hidden")}showGameBoard(){this.elements.gameBoardContainer.classList.remove("hidden"),this.elements.gameInfoSection.classList.remove("hidden"),this.elements.gameStatsBottom.classList.remove("hidden"),this.elements.gameModeSection.style.display="none"}hideGameBoard(){this.elements.gameBoardContainer.classList.add("hidden"),this.elements.gameInfoSection.classList.add("hidden"),this.elements.gameStatsBottom.classList.add("hidden"),this.elements.gameIdDisplay.classList.add("hidden"),this.elements.gameModeSection.style.display="block"}updateGameInfo(e,t,a){this.elements.gameIdValue.textContent=e;const n=this.gameManager.accountManager.getAddress(),i=t===n?`YOU (${this.shortenAddress(t)})`:this.shortenAddress(t),o=a===n?`YOU (${this.shortenAddress(a)})`:this.shortenAddress(a);this.elements.playerXAddress.textContent=i,this.elements.playerOAddress.textContent=o,this.elements.gameIdDisplay.classList.remove("hidden")}showGameEndMessage(e,t){this.elements.gameMessage.textContent=e,this.elements.gameMessage.className=`game-message ${t}`,this.elements.gameMessage.classList.remove("hidden")}hideGameMessage(){this.elements.gameMessage.classList.add("hidden")}updateGameStats(e){this.elements.xWins.textContent=e.xWins,this.elements.oWins.textContent=e.oWins,this.elements.draws.textContent=e.draws}showTimeoutSection(){this.elements.timeoutSection.classList.remove("hidden")}hideTimeoutSection(){this.elements.timeoutSection.classList.add("hidden")}updateTimeoutCountdown(e){this.elements.timeoutCountdown.textContent=e}showClaimTimeoutBtn(){this.elements.claimTimeoutBtn.classList.remove("hidden")}hideClaimTimeoutBtn(){this.elements.claimTimeoutBtn.classList.add("hidden")}showGameWaitingOverlay(){this.elements.gameWaitingOverlay&&this.elements.gameWaitingOverlay.classList.remove("hidden")}hideGameWaitingOverlay(){this.elements.gameWaitingOverlay&&this.elements.gameWaitingOverlay.classList.add("hidden")}renderTransactionHistory(e){if(e.length===0){this.elements.transactionHistory.innerHTML='<p class="no-transactions">No transactions yet. Send your first transaction to see it here!</p>';return}this.elements.transactionHistory.innerHTML=e.map(t=>{const a=t.status,n=this.formatTiming(t.timing);return`
                <div class="tx-item ${a}">
                    <div class="tx-header">
                        <div class="tx-status">${t.statusText}</div>
                        <div class="tx-time">${new Date(t.timing.submitted).toLocaleTimeString()}</div>
                    </div>
                    <div class="tx-details">
                        <div><strong>From:</strong> ${this.shortenAddress(t.from)}</div>
                        <div><strong>To:</strong> ${t.to}</div>
                        <div><strong>Action:</strong> ${t.amount}</div>
                        ${t.hash?`<div><strong>Hash:</strong> <span class="tx-hash">${this.shortenHash(t.hash)}</span></div>`:""}
                    </div>
                    ${n?`<div class="tx-timing">${n}</div>`:""}
                </div>
            `}).join("")}updatePendingCount(e){e>0?(this.elements.pendingCount.textContent=`⏳ ${e} pending`,this.elements.pendingCount.classList.remove("hidden")):this.elements.pendingCount.classList.add("hidden")}initializeChart(){if(this.chart){console.log("Chart already initialized");return}if(!this.elements.timingChart){console.error("Chart canvas element not found");return}if(typeof Chart>"u"){console.error("Chart.js library not loaded yet");return}try{console.log("Initializing transaction timing chart...");const e=this.elements.timingChart.getContext("2d");this.chart=new Chart(e,{type:"line",data:{labels:[],datasets:[{label:"Ready",data:[],borderColor:"rgb(75, 192, 192)",backgroundColor:"rgba(75, 192, 192, 0.2)",borderWidth:2,tension:.1,spanGaps:!0},{label:"InBlock",data:[],borderColor:"rgb(255, 159, 64)",backgroundColor:"rgba(255, 159, 64, 0.2)",borderWidth:2,tension:.1,spanGaps:!0},{label:"Finalized",data:[],borderColor:"rgb(153, 102, 255)",backgroundColor:"rgba(153, 102, 255, 0.2)",borderWidth:2,tension:.1,spanGaps:!0}]},options:{responsive:!0,maintainAspectRatio:!0,aspectRatio:2,plugins:{legend:{position:"top",labels:{color:"#c5d9c5"}},title:{display:!0,text:"Transaction Timing (ms)",color:"#c5d9c5"}},scales:{y:{beginAtZero:!0,ticks:{color:"#c5d9c5"},grid:{color:"rgba(197, 217, 197, 0.1)"}},x:{ticks:{color:"#c5d9c5"},grid:{color:"rgba(197, 217, 197, 0.1)"}}}}}),console.log("✅ Chart initialized successfully")}catch(e){console.error("Failed to initialize chart:",e),this.chart=null}}updateChart(e){if(console.log("📊 updateChart called with",e.length,"transactions"),this.chart||(console.log("Chart not initialized, initializing now..."),this.initializeChart()),!this.chart){console.warn("Chart initialization failed, cannot update");return}const t=e.filter(s=>s.timing.ready).slice(0,20).reverse();if(console.log("Found",t.length,"transactions with timing data for chart"),t.length===0){console.log("No transactions with timing data to display"),this.chart.data.labels=[],this.chart.data.datasets[0].data=[],this.chart.data.datasets[1].data=[],this.chart.data.datasets[2].data=[],this.chart.update();return}const a=t.map((s,r)=>`TX ${r+1}`),n=t.map(s=>s.timing.ready?s.timing.ready-s.timing.submitted:null),i=t.map(s=>s.timing.inBlock?s.timing.inBlock-s.timing.submitted:null),o=t.map(s=>s.timing.finalized?s.timing.finalized-s.timing.submitted:null);console.log("Chart data:",{labels:a,ready:n.filter(s=>s!==null).length+" values",inBlock:i.filter(s=>s!==null).length+" values",finalized:o.filter(s=>s!==null).length+" values"}),this.chart.data.labels=a,this.chart.data.datasets[0].data=n,this.chart.data.datasets[1].data=i,this.chart.data.datasets[2].data=o,this.chart.update(),console.log("✅ Chart updated")}updateTransactionStats(e){if(console.log("📈 updateTransactionStats called with:",e),!e){console.log("No stats available, hiding stats section"),this.elements.statsContent.classList.add("hidden");return}this.elements.statsContent.classList.remove("hidden");const t=(a,n)=>n===0?"-":`${Math.round(a)}ms`;this.elements.minReady.textContent=t(e.ready.min,e.ready.count),this.elements.maxReady.textContent=t(e.ready.max,e.ready.count),this.elements.avgReady.textContent=t(e.ready.avg,e.ready.count),this.elements.minInBlock.textContent=t(e.inBlock.min,e.inBlock.count),this.elements.maxInBlock.textContent=t(e.inBlock.max,e.inBlock.count),this.elements.avgInBlock.textContent=t(e.inBlock.avg,e.inBlock.count),this.elements.minFinalized.textContent=t(e.finalized.min,e.finalized.count),this.elements.maxFinalized.textContent=t(e.finalized.max,e.finalized.count),this.elements.avgFinalized.textContent=t(e.finalized.avg,e.finalized.count),console.log("✅ Stats updated:",{ready:e.ready.count,inBlock:e.inBlock.count,finalized:e.finalized.count})}showBlockBanner(){this.elements.blockBanner.classList.remove("hidden")}updateBlockWindow(e,t){this.elements.blockWindow.innerHTML=e.map(a=>`
                <div class="block-item ${a.number<=t?"finalized":""} new-block">
                    <div class="block-number">#${a.number}</div>
                    <div class="block-hash-short">${a.hash.slice(0,8)}...</div>
                </div>
            `).join("")}shortenAddress(e){return e?e.length<16?e:`${e.slice(0,6)}...${e.slice(-6)}`:"-"}shortenHash(e){return e?`${e.slice(0,10)}...${e.slice(-8)}`:"-"}formatTiming(e){const t=[];return e.ready&&t.push(`Ready: ${e.ready-e.submitted}ms`),e.inBlock&&t.push(`InBlock: ${e.inBlock-e.submitted}ms`),e.finalized&&t.push(`Finalized: ${e.finalized-e.submitted}ms`),t.join(" | ")}}class C{constructor(){this.chainManager=new b,this.accountManager=new B(this.chainManager),this.gameManager=new T(this.chainManager,this.accountManager),this.matchmakingManager=new v(this.chainManager,this.accountManager),this.transactionManager=new w,this.uiManager=new k(this.gameManager),this.timeoutTimer=null,this.timeoutStartTime=null,this.TIMEOUT_SECONDS=60,this.init()}init(){this.setupEventListeners(),this.uiManager.updateGameStats(this.gameManager.gameStats),setTimeout(()=>{this.uiManager.initializeChart()},100)}setupEventListeners(){this.uiManager.elements.connectBtn.addEventListener("click",()=>this.handleConnect()),this.uiManager.elements.connectWalletBtn.addEventListener("click",()=>this.handleConnectWallet()),this.uiManager.elements.useSeedBtn.addEventListener("click",()=>this.uiManager.showSeedInput()),this.uiManager.elements.importSeedBtn.addEventListener("click",()=>this.handleImportSeed()),this.uiManager.elements.cancelSeedBtn.addEventListener("click",()=>this.uiManager.hideSeedInput()),this.uiManager.elements.playGameBtn.addEventListener("click",()=>this.handlePlayGame()),this.uiManager.elements.cancelMatchmakingBtn.addEventListener("click",()=>this.handleCancelMatchmaking()),this.uiManager.elements.resetGameBtn.addEventListener("click",()=>this.handleResetGame()),document.querySelectorAll(".cell").forEach(e=>{e.addEventListener("click",t=>{const a=parseInt(t.target.getAttribute("data-cell"));this.handleCellClick(a)})}),this.uiManager.elements.clearHistoryBtn.addEventListener("click",()=>{this.transactionManager.clearHistory(),this.uiManager.renderTransactionHistory([]),this.uiManager.updatePendingCount(0),this.uiManager.updateChart([]),this.uiManager.updateTransactionStats(null)}),this.uiManager.elements.claimTimeoutBtn.addEventListener("click",()=>this.handleClaimTimeout())}async handleConnect(){const e=this.uiManager.elements.rpcUrl.value.trim(),t=this.uiManager.elements.connectBtn;if(!e){alert("Please enter a valid RPC URL");return}try{t.textContent="Connecting...",t.disabled=!0,await this.chainManager.connect(e);const a=await this.chainManager.getChainInfo();this.uiManager.updateConnectionStatus(!0,"Connected"),this.uiManager.showChainInfo(a.chain,a.version),this.uiManager.showBlockBanner(),this.chainManager.subscribeToBlocks(async()=>{if(this.accountManager.isConnected())try{const n=await this.accountManager.getBalance();this.uiManager.updateBalance(n)}catch(n){console.error("Error updating balance:",n)}}),this.gameManager.subscribeToGameEvents(async(n,i)=>{await this.handleGameEvent(n,i)}),t.textContent="Connected",t.disabled=!1}catch(a){console.error("Connection error:",a),alert(`Failed to connect: ${a.message}`),this.uiManager.updateConnectionStatus(!1,"Disconnected"),t.textContent="Connect",t.disabled=!1}}async handleConnectWallet(){try{const e=await this.accountManager.connectWallet();this.uiManager.updateAccountInfo(e.address,"extension"),this.accountManager.startBalanceUpdates(a=>{this.uiManager.updateBalance(a)});const t=await this.accountManager.getBalance();this.uiManager.updateBalance(t),await this.checkAndJoinActiveGame()}catch(e){console.error("Wallet connection error:",e),alert(e.message)}}async handleImportSeed(){const e=this.uiManager.elements.seedPhrase.value.trim();if(!e){alert("Please enter a seed string");return}try{const t=await this.accountManager.createFromSeed(e);this.uiManager.hideSeedInput(),this.uiManager.updateAccountInfo(t.address,"seed"),this.accountManager.startBalanceUpdates(n=>{this.uiManager.updateBalance(n)});const a=await this.accountManager.getBalance();this.uiManager.updateBalance(a),await this.checkAndMintFunds(a),await this.checkAndJoinActiveGame()}catch(t){console.error("Seed import error:",t),alert(`Failed to create account: ${t.message}`)}}async handlePlayGame(){if(!this.chainManager.isConnected()||!this.accountManager.isConnected()){alert("Please connect to chain and wallet first");return}const e=this.uiManager.elements.playGameBtn;try{e.disabled=!0,e.textContent="JOINING QUEUE...";const t=await this.matchmakingManager.joinQueue(),a=this.transactionManager.createTransaction("matchmaking",this.accountManager.getAddress(),"Matchmaking","Start Game"),n=await this.accountManager.signAndSend(t,async i=>{await this.handleTransactionStatus(i,a,n,o=>{o.type==="PlayerJoinedQueue"?this.uiManager.showMatchmakingWaiting():o.type==="GameCreated"&&(this.uiManager.hideMatchmakingWaiting(),this.matchmakingManager.setInQueue(!1))})})}catch(t){console.error("Matchmaking error:",t),alert(`Failed to join matchmaking: ${t.message}`),e.textContent="START GAME",e.disabled=!1}}async handleCancelMatchmaking(){try{const e=await this.matchmakingManager.cancelQueue(),t=await this.accountManager.signAndSend(e,a=>{a.status.isInBlock&&(this.uiManager.hideMatchmakingWaiting(),t())})}catch(e){console.error("Cancel matchmaking error:",e),alert(`Failed to cancel matchmaking: ${e.message}`)}}async checkAndMintFunds(e){if(!(!this.chainManager.isConnected()||!this.accountManager.isConnected()))try{const t=parseFloat(e);if(isNaN(t)||t===0){console.log("💰 Balance is 0, minting funds...");const a=this.transactionManager.createTransaction("mint_funds",this.accountManager.getAddress(),"Tic-Tac-Toe Pallet","Mint 1000 UNIT"),n=this.chainManager.api.registry.chainDecimals[0]||12,i=1e3*Math.pow(10,n),o=this.chainManager.api.tx.ticTacToe.mintFunds(this.accountManager.currentAccount.address,i),s=await this.accountManager.sendUnsigned(o,async r=>{await this.handleTransactionStatus(r,a,s)})}}catch(t){console.error("Error checking/minting funds:",t)}}async checkAndJoinActiveGame(){if(!(!this.chainManager.isConnected()||!this.accountManager.isConnected()))try{console.log("Checking for active game...");const e=await this.gameManager.getPlayerGame();if(console.log("Game found:",e),!e){console.log("No active game found");return}const[t,a]=e;console.log(`Auto-loading active game #${t}`,a),await this.setupAndShowGame(t,a.player_x.toString(),a.player_o.toString(),a);const n=this.gameManager.getGameInfo();console.log("Game auto-loaded. Active:",n.gameActive,"ID:",n.currentGameId)}catch(e){console.error("Error checking for active game:",e)}}async handleCellClick(e){const t=this.gameManager.getGameInfo();if(console.log("Cell clicked:",e,"Game info:",t),!t.gameActive){console.warn("Game not active!"),alert("Game is not active. Please start a game first.");return}if(t.gameBoard[e]!==null){console.warn("Cell already taken!");return}if(t.currentGameId===null||t.currentGameId===void 0){alert("Please start a game first");return}try{this.uiManager.showGameWaitingOverlay();const a=await this.gameManager.makeMove(e),n=this.transactionManager.createTransaction("game_move",this.accountManager.getAddress(),`Game #${t.currentGameId}`,`Move at [${e}]`),i=await this.accountManager.signAndSend(a,async o=>{await this.handleTransactionStatus(o,n,i),o.status.isInBlock&&(this.uiManager.hideGameWaitingOverlay(),this.startTimeoutTimer()),o.status.isFinalized&&this.uiManager.hideGameWaitingOverlay()})}catch(a){console.error("Move error:",a),this.uiManager.hideGameWaitingOverlay(),alert(`Failed to make move: ${a.message}`)}}handleResetGame(){this.stopTimeoutTimer(),this.gameManager.resetGame(),this.uiManager.hideGameBoard(),this.uiManager.hideGameMessage(),this.uiManager.hideMatchmakingWaiting(),this.uiManager.hideTimeoutSection(),this.uiManager.updateBoardFromState({board:Array(9).fill(null)})}startTimeoutTimer(){console.log("⏱️ Starting timeout timer (opponent's turn)"),this.stopTimeoutTimer(!1),this.timeoutStartTime=Date.now(),this.uiManager.showTimeoutSection(),this.uiManager.hideClaimTimeoutBtn(),this.timeoutTimer=setInterval(()=>{const e=Math.floor((Date.now()-this.timeoutStartTime)/1e3),t=Math.max(0,this.TIMEOUT_SECONDS-e);this.uiManager.updateTimeoutCountdown(t),t===0&&(console.log("⏱️ Timeout expired! Showing claim button"),clearInterval(this.timeoutTimer),this.timeoutTimer=null,this.uiManager.showClaimTimeoutBtn())},1e3)}stopTimeoutTimer(e=!0){this.timeoutTimer&&(console.log("⏱️ Stopping timeout timer (your turn or game ended)"),clearInterval(this.timeoutTimer),this.timeoutTimer=null),this.timeoutStartTime=null,e&&this.uiManager.hideTimeoutSection()}async handleClaimTimeout(){if(this.gameManager.getGameInfo().currentGameId===null||this.gameManager.getGameInfo().currentGameId===void 0){alert("No active game");return}if(confirm("Claim victory due to opponent timeout?"))try{const t=await this.gameManager.claimTimeout(),a=this.transactionManager.createTransaction("claim_timeout",this.accountManager.getAddress(),`Game #${this.gameManager.getGameInfo().currentGameId}`,"Claim Timeout Victory"),n=await this.accountManager.signAndSend(t,async i=>{await this.handleTransactionStatus(i,a,n)});this.stopTimeoutTimer()}catch(t){console.error("Claim timeout error:",t),alert(`Failed to claim timeout: ${t.message}`)}}async handleGameEvent(e,t){switch(await this.gameManager.gameState.handleEvent(e,t),e){case"gameCreated":const a=this.accountManager.getAddress();if((t.playerX===a||t.playerO===a)&&this.matchmakingManager.isInQueue()){console.log("Matched! Loading game..."),this.uiManager.hideMatchmakingWaiting(),this.matchmakingManager.setInQueue(!1);const o=this.gameManager.gameState;o.gameId!==null&&(this.uiManager.showGameBoard(),this.uiManager.updateGameInfo(o.gameId,o.playerX,o.playerO),o.isMyTurn||this.startTimeoutTimer())}break;case"moveMade":this.gameManager.gameState.isMyTurn?(console.log("It's my turn, stopping timeout"),this.stopTimeoutTimer()):(console.log("It's opponent's turn, starting timeout"),this.startTimeoutTimer());break;case"gameEnded":this.stopTimeoutTimer();const i=this.gameManager.handleGameEnd(t.state);this.uiManager.showGameEndMessage(i.message,i.winnerType),this.uiManager.updateGameStats(i.stats);break}}async setupAndShowGame(e,t,a,n=null){try{console.log("Setting up game:",{gameId:e,playerX:t,playerO:a,hasExistingData:!!n});const i=await this.gameManager.setupGame(e,t,a,n);console.log("Setup result:",i),this.uiManager.showGameBoard(),this.uiManager.updateGameInfo(e,t,a);const o=this.gameManager.getGameInfo();if(console.log("Game info:",o),this.uiManager.updateGameStats(o.gameStats),i&&i.ended){this.stopTimeoutTimer();const r=this.gameManager.handleGameEnd(i.state);this.uiManager.showGameEndMessage(r.message,r.winnerType)}else this.gameManager.gameState.isMyTurn?this.stopTimeoutTimer():this.startTimeoutTimer();const s=this.gameManager.getGameInfo();console.log("Game setup complete. Final game state:",s),s.gameActive?s.currentGameId===null||s.currentGameId===void 0?(console.error("WARNING: No game ID set after setup!"),console.error("Final state:",s),console.error("Passed game ID:",e),alert("Game setup completed but no game ID. Please try again.")):console.log("✓ Game is ready to play!"):(console.error("WARNING: Game is not active after setup!"),console.error("Final state:",s))}catch(i){console.error("Setup game error:",i),console.error("Stack:",i.stack),alert(`Failed to setup game: ${i.message}`)}}async handleTransactionStatus(e,t,a,n){const{status:i,dispatchError:o}=e;if(i.isInvalid){t.timing.invalid=Date.now(),t.status="error",t.statusText="Invalid",this.updateTransactionUI(t);return}if(e.txHash&&!t.hash&&(t.hash=e.txHash.toHex()),i.isReady&&(t.timing.ready=Date.now(),t.statusText="Ready",this.updateTransactionUI(t)),i.isInBlock){if(t.timing.inBlock=Date.now(),t.status="success",t.statusText="In Block",t.blockHash=i.asInBlock.toHex(),this.updateTransactionUI(t),o){let s="";if(o.isModule){const r=this.chainManager.api.registry.findMetaError(o.asModule);s=`${r.section}.${r.name}`}else s=o.toString();alert(`Transaction failed: ${s}`),a();return}if(n)try{const s=await this.chainManager.api.query.system.events.at(i.asInBlock);for(const{event:r}of s)this.chainManager.api.events.ticTacToe.PlayerJoinedQueue.is(r)&&n({type:"PlayerJoinedQueue"}),this.chainManager.api.events.ticTacToe.GameCreated.is(r)&&n({type:"GameCreated"})}catch(s){console.error("Error reading events:",s)}}i.isFinalized&&(t.timing.finalized=Date.now(),t.statusText="Finalized ✓",t.finalizedBlockHash=i.asFinalized.toHex(),this.updateTransactionUI(t),a())}updateTransactionUI(e){let t;this.transactionManager.getHistory().find(i=>i.id===e.id)?t=this.transactionManager.updateInHistory(e.hash||e.id,e):t=this.transactionManager.addToHistory(e),this.uiManager.renderTransactionHistory(t),this.uiManager.updatePendingCount(this.transactionManager.getPendingCount()),this.uiManager.updateChart(t);const n=this.transactionManager.calculateStats();this.uiManager.updateTransactionStats(n)}}document.addEventListener("DOMContentLoaded",()=>{window.app=new C});
