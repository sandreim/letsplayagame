import{W as m,A as g,w as p,a as y,c as f,K as M,b as T}from"./polkadot-2dd106b8.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))n(a);new MutationObserver(a=>{for(const i of a)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function t(a){const i={};return a.integrity&&(i.integrity=a.integrity),a.referrerPolicy&&(i.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?i.credentials="include":a.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(a){if(a.ep)return;a.ep=!0;const i=t(a);fetch(a.href,i)}})();class b{constructor(){this.api=null,this.unsubscribeBlocks=null,this.unsubscribeFinalizedBlocks=null,this.blockWindow=[],this.maxBlocksInWindow=50,this.finalizedBlockNumber=0,this.blockTimestamps=new Map,this.onBlockCallback=null}async connect(e){this.api&&(await this.api.disconnect(),this.stopBlockSubscription());const t=new m(e),n={Cell:{_enum:["Empty","X","O"]},GameState:{_enum:["InProgress","XWon","OWon","Draw"]},Game:{player_x:"AccountId",player_o:"AccountId",x_turn:"bool",board:"[Cell; 9]",state:"GameState"}};return this.api=await g.create({provider:t,noInitWarn:!0,types:n}),await this.api.isReady,this.api}async callRuntimeAPI(e,t,n=[]){if(!this.api)throw new Error("API not connected");const a=`${e}_${t}`;console.log(`Calling runtime API: ${a}`),console.log("Params:",n.map(s=>({value:s.toString(),hex:s.toHex(),u8a:Array.from(s.toU8a())})));let i="0x";if(n.length>0){const s=[];n.forEach(r=>{const l=r.toU8a();s.push(...l)}),i=this.api.createType("Bytes",s).toHex()}console.log("Encoded params (hex):",i);const o=await this.api.rpc.state.call(a,i);return console.log("Raw result:",o.toHex()),o}async disconnect(){this.api&&(await this.api.disconnect(),this.api=null),this.stopBlockSubscription()}async getChainInfo(){if(!this.api)throw new Error("Not connected to chain");const[e,t]=await Promise.all([this.api.rpc.system.chain(),this.api.rpc.system.version()]);return{chain:e.toString(),version:t.toString()}}async subscribeToBlocks(e){this.api&&(this.onBlockCallback=e,this.unsubscribeBlocks=await this.api.rpc.chain.subscribeNewHeads(t=>{this.updateBlockInfo(t),e&&e()}),this.unsubscribeFinalizedBlocks=await this.api.rpc.chain.subscribeFinalizedHeads(t=>{this.updateFinalizedBlockInfo(t)}))}updateBlockInfo(e){const t=e.number.toNumber(),n=e.hash.toString(),a=Date.now();this.blockTimestamps.set(t,a),this.addBlockToWindow(t,n,!1)}updateFinalizedBlockInfo(e){const t=e.number.toNumber();this.finalizedBlockNumber=t,this.markFinalizedBlocks()}addBlockToWindow(e,t,n){if(this.blockWindow.findIndex(s=>s.number===e)!==-1)return;const i={number:e,hash:t,isFinalized:n||e<=this.finalizedBlockNumber};this.blockWindow.push(i),this.blockWindow.sort((s,r)=>r.number-s.number);const o=document.getElementById("blockWindow");if(o){const s=o.offsetWidth,h=Math.floor(s/(42+4));if(this.blockWindow.length>h){this.blockWindow=this.blockWindow.slice(0,h);const d=new Set(this.blockWindow.map(u=>u.number));for(const[u]of this.blockTimestamps)d.has(u)||this.blockTimestamps.delete(u)}}this.renderBlockWindow()}markFinalizedBlocks(){this.blockWindow.forEach(e=>{e.number<=this.finalizedBlockNumber&&(e.isFinalized=!0)}),this.renderBlockWindow()}renderBlockWindow(){const e=document.getElementById("blockWindow"),t=document.getElementById("blockTimeline");!e||!t||(e.innerHTML="",this.blockWindow.forEach((n,a)=>{const i=document.createElement("div");i.className="block-item",n.isFinalized&&i.classList.add("finalized"),a===0&&i.classList.add("new-block");const o=`${n.hash.slice(2,6)}${n.hash.slice(-2)}`;i.innerHTML=`
                <div class="block-number">${n.number}</div>
                <div class="block-hash-short">${o}</div>
            `;const s=this.blockTimestamps.get(n.number),r=s?new Date(s).toLocaleTimeString():"";i.title=`Block #${n.number.toLocaleString()}
${n.hash}
${r}
${n.isFinalized?"✓ Finalized":"Pending"}`,e.appendChild(i)}),t.innerHTML="",this.blockWindow.forEach((n,a)=>{const i=document.createElement("div");i.className="timeline-tick";const o=this.blockTimestamps.get(n.number);let s="--";if(o&&a<this.blockWindow.length-1){const r=this.blockWindow[a+1],l=this.blockTimestamps.get(r.number);if(l){const d=((o-l)/1e3).toFixed(1);s=`${d}s`,parseFloat(d)>=10&&i.classList.add("major")}}i.innerHTML=`
                <div class="tick-mark"></div>
                <div class="tick-time">${s}</div>
            `,t.appendChild(i)}))}stopBlockSubscription(){this.unsubscribeBlocks&&(this.unsubscribeBlocks(),this.unsubscribeBlocks=null),this.unsubscribeFinalizedBlocks&&(this.unsubscribeFinalizedBlocks(),this.unsubscribeFinalizedBlocks=null)}isConnected(){return this.api!==null&&this.api.isConnected}}class I{constructor(e){this.chainManager=e,this.currentAccount=null,this.keyring=null,this.keyringPair=null,this.accountType=null,this.accountUpdateInterval=null,this.lastAccountUpdate=0,this.accountUpdateThrottle=3e3}async connectWallet(){try{if((await p("Polkadot Tic-Tac-Toe")).length===0)throw new Error("No extension installed. Please install Polkadot.js extension.");const t=await y();if(t.length===0)throw new Error("No accounts found. Please create an account in your Polkadot.js extension.");return this.currentAccount=t[0],this.accountType="extension",this.currentAccount}catch(e){throw console.error("Error connecting wallet:",e),e}}async createFromSeed(e){try{return await f(),this.keyring||(this.keyring=new M({type:"sr25519"})),this.keyringPair=this.keyring.addFromUri(e),this.currentAccount={address:this.keyringPair.address,meta:{name:"Seed Account",source:"seed"}},this.accountType="seed",this.currentAccount}catch(t){throw console.error("Error creating account from seed:",t),t}}async getBalance(){if(!this.currentAccount||!this.chainManager.api)return null;const{data:e}=await this.chainManager.api.query.system.account(this.currentAccount.address),t=this.chainManager.api.registry.chainDecimals[0]||12,n=Math.pow(10,t),a=i=>(parseFloat(i.toString())/n).toFixed(4);return{free:a(e.free),reserved:a(e.reserved),frozen:a(e.frozen)}}startBalanceUpdates(e){this.accountUpdateInterval=setInterval(async()=>{const t=Date.now();if(t-this.lastAccountUpdate>=this.accountUpdateThrottle){this.lastAccountUpdate=t;try{const n=await this.getBalance();e(n)}catch(n){console.error("Error updating balance:",n)}}},this.accountUpdateThrottle)}stopBalanceUpdates(){this.accountUpdateInterval&&(clearInterval(this.accountUpdateInterval),this.accountUpdateInterval=null)}async signAndSend(e,t){if(this.accountType==="seed")return await e.signAndSend(this.keyringPair,t);{const n=await T(this.currentAccount.address);return await e.signAndSend(this.currentAccount.address,{signer:n.signer},t)}}async sendUnsigned(e,t){return await e.send(t)}disconnect(){this.stopBalanceUpdates(),this.currentAccount=null,this.accountType=null,this.keyringPair=null}isConnected(){return this.currentAccount!==null}getAddress(){return this.currentAccount?.address||null}}class S{constructor(e,t){this.chainManager=e,this.accountManager=t,this.gameId=null,this.isActive=!1,this.board=Array(9).fill(null),this.playerSymbol=null,this.opponentAddress=null,this.playerX=null,this.playerO=null,this.isMyTurn=!1,this.isEnded=!1,this.gameState=null,this.onStateChangeCallbacks=[]}onStateChange(e){this.onStateChangeCallbacks.push(e)}notifyStateChange(){console.log(`🔔 notifyStateChange called. Callbacks: ${this.onStateChangeCallbacks.length}`),console.log("   State:",{gameId:this.gameId,isMyTurn:this.isMyTurn,playerSymbol:this.playerSymbol,isActive:this.isActive,isEnded:this.isEnded}),this.onStateChangeCallbacks.forEach((e,t)=>{try{console.log(`  Calling callback #${t}`),e(this)}catch(n){console.error(`Error in state change callback #${t}:`,n)}})}initialize(e,t,n){const a=this.accountManager.getAddress();if(a!==t&&a!==n)throw new Error("You are not a player in this game");this.gameId=e,this.playerX=t,this.playerO=n,this.playerSymbol=a===t?"X":"O",this.opponentAddress=a===t?n:t,this.isActive=!0,console.log(`Game ${e} initialized. You are Player ${this.playerSymbol}`)}async getPlayerGame(){if(!this.chainManager.api||!this.accountManager.isConnected())return null;try{const e=this.accountManager.getAddress();console.log("Fetching active game for player:",e);const t=this.chainManager.api,n=t.createType("AccountId32",e),a=await this.chainManager.callRuntimeAPI("TicTacToeApi","get_player_game",[n]),i=t.createType("Option<(u32, Game)>",a);if(i.isNone)return console.log("No active game found"),null;const[o,s]=i.unwrap();return console.log(`Found active game #${o.toNumber()}`),[o.toNumber(),s]}catch(e){throw console.error("Error fetching player game:",e),e}}async refresh(){if(!this.chainManager.api)return console.warn("Cannot refresh: API not ready"),!1;try{console.log("Refreshing game state from chain...");const e=await this.getPlayerGame();if(!e)return console.log("No active game found for player"),this.gameId!==null&&(console.log("Previous game has ended"),this.isActive=!1,this.isEnded=!0),!1;const[t,n]=e;console.log(`Refreshing game #${t} from chain:`,n.toHuman()),this.gameId!==t&&(console.log(`Game ID changed from ${this.gameId} to ${t}, re-initializing`),this.initialize(t,n.player_x.toString(),n.player_o.toString())),this.updateBoard(n.board);const a=n.x_turn!==void 0?n.x_turn:n.xTurn,i=this.isMyTurn;console.log("🔄 Turn data from chain:",{"gameData.x_turn":n.x_turn,"gameData.xTurn":n.xTurn,"resolved xTurn":a,"xTurn type":typeof a,"xTurn.valueOf()":a?.valueOf?a.valueOf():a,playerSymbol:this.playerSymbol,oldIsMyTurn:i});const o=a?.valueOf?a.valueOf():!!a;this.isMyTurn=this.playerSymbol==="X"&&o||this.playerSymbol==="O"&&!o,console.log("Turn calculation result:",{xTurnBool:o,playerSymbol:this.playerSymbol,oldIsMyTurn:i,newIsMyTurn:this.isMyTurn,"newIsMyTurn type":typeof this.isMyTurn,changed:i!==this.isMyTurn});const s=n.state;return this.gameState=s,s.isInProgress||(this.isActive=!1,this.isEnded=!0,console.log("Game has ended:",s.toHuman())),console.log(`✓ Refreshed game #${this.gameId}:`,{board:this.board,isMyTurn:this.isMyTurn,isEnded:this.isEnded,state:this.gameState?.toHuman()}),this.notifyStateChange(),!0}catch(e){return console.error("Error refreshing game state:",e),!1}}updateBoard(e){const t=Array(9).fill(null);e.forEach((n,a)=>{const i=this.decodeCellValue(n);i&&(t[a]=i)}),this.board=t,console.log("Board updated:",t)}decodeCellValue(e){return e.isX||e.toHuman?.()==="X"||e.toJSON?.()==="X"?"X":e.isO||e.toHuman?.()==="O"||e.toJSON?.()==="O"?"O":null}async handleEvent(e,t){switch(console.log(`🎮 GameState handling event: ${e}`,t),e){case"gameCreated":const n=this.accountManager.getAddress();(t.playerX===n||t.playerO===n)&&(console.log("New game created for us, refreshing state..."),await this.refresh());break;case"moveMade":console.log("Move made, refreshing state..."),await this.refresh();break;case"gameEnded":console.log("Game ended, marking as inactive"),this.isActive=!1,this.isEnded=!0,this.notifyStateChange();break}}reset(){this.gameId=null,this.isActive=!1,this.board=Array(9).fill(null),this.playerSymbol=null,this.opponentAddress=null,this.playerX=null,this.playerO=null,this.isMyTurn=!1,this.isEnded=!1,this.gameState=null,console.log("Game state reset"),this.notifyStateChange()}toJSON(){return{gameId:this.gameId,isActive:this.isActive,isEnded:this.isEnded,board:this.board,playerSymbol:this.playerSymbol,opponentAddress:this.opponentAddress,playerX:this.playerX,playerO:this.playerO,isMyTurn:this.isMyTurn,gameState:this.gameState?.toHuman?.()||this.gameState}}}class B{constructor(e,t){this.chainManager=e,this.accountManager=t,this.gameState=new S(e,t),this.eventsSubscribed=!1,this.gameStats={xWins:0,oWins:0,draws:0},this.loadGameStats()}async getPlayerGame(){return await this.gameState.getPlayerGame()}async setupGame(e,t,n,a=null){try{if(console.log("setupGame called with:",{gameId:e,playerX:t,playerO:n,hasExistingData:!!a}),this.gameState.initialize(e,t,n),await this.gameState.refresh(),console.log("✓ Game setup complete:",this.gameState.toJSON()),this.gameState.isEnded){const i=this.gameState.gameState,o=i.toHuman();if(o==="XWon"||i.isXWon)return{ended:!0,state:1};if(o==="OWon"||i.isOWon)return{ended:!0,state:2};if(o==="Draw"||i.isDraw)return{ended:!0,state:3}}return{ended:!1}}catch(i){throw console.error("Error setting up game:",i),i}}async makeMove(e){if(!this.chainManager.api||!this.accountManager.isConnected())throw new Error("Not connected to chain or wallet");return console.log(`Making on-chain move: game ${this.gameState.gameId}, position ${e}`),this.chainManager.api.tx.ticTacToe.makeMove(this.gameState.gameId,e)}async claimTimeout(){if(!this.chainManager.api||!this.accountManager.isConnected())throw new Error("Not connected to chain or wallet");if(this.gameState.gameId===null||this.gameState.gameId===void 0)throw new Error("No active game");return console.log(`Claiming timeout victory for game ${this.gameState.gameId}`),this.chainManager.api.tx.ticTacToe.claimTimeout(this.gameState.gameId)}handleGameEnd(e){this.gameState.isActive=!1,this.gameState.isEnded=!0;let t="",n=null;switch(e){case 1:t="🎉 Player X wins!",n="winner",this.gameState.playerSymbol==="X"&&this.gameStats.xWins++;break;case 2:t="🎉 Player O wins!",n="winner",this.gameState.playerSymbol==="O"&&this.gameStats.oWins++;break;case 3:t="🤝 It's a draw!",n="draw",this.gameStats.draws++;break}return this.saveGameStats(),this.gameState.notifyStateChange(),{message:t,winnerType:n,stats:this.gameStats}}resetGame(){this.gameState.reset(),this.eventsSubscribed=!1}subscribeToGameEvents(e){if(this.eventsSubscribed||!this.chainManager.api){console.log("Events already subscribed or API not ready");return}console.log("Subscribing to game events..."),this.eventsSubscribed=!0,this.chainManager.api.query.system.events(async t=>{for(const{event:n}of t)if(this.chainManager.api.events.ticTacToe.MoveMade.is(n)){const[a,i,o]=n.data;a.toNumber()===this.gameState.gameId&&(console.log(`Move made in game ${a} by ${i} at position ${o}`),e("moveMade",{gameId:a.toNumber()}))}t.forEach(({event:n})=>{if(this.chainManager.api.events.ticTacToe.GameCreated.is(n)){const[a,i,o]=n.data;e("gameCreated",{gameId:a.toNumber(),playerX:i.toString(),playerO:o.toString()})}if(this.chainManager.api.events.ticTacToe.GameEnded.is(n)){const[a,i]=n.data;a.toNumber()===this.gameState.gameId&&(console.log(`Current game ${a} ended with state: ${i}`),e("gameEnded",{gameId:a.toNumber(),state:i.toNumber()}))}})})}saveGameStats(){localStorage.setItem("tictactoe_stats",JSON.stringify(this.gameStats))}loadGameStats(){const e=localStorage.getItem("tictactoe_stats");if(e)try{this.gameStats=JSON.parse(e)}catch(t){console.error("Error loading game stats:",t)}}getGameInfo(){return{currentGameId:this.gameState.gameId,currentPlayerSymbol:this.gameState.playerSymbol,opponentAddress:this.gameState.opponentAddress,gameActive:this.gameState.isActive,gameBoard:this.gameState.board,gameStats:this.gameStats}}}class w{constructor(e,t){this.chainManager=e,this.accountManager=t,this.inQueue=!1}async joinQueue(){if(!this.chainManager.api||!this.accountManager.isConnected())throw new Error("Not connected to chain or wallet");return console.log("Joining matchmaking queue..."),this.inQueue=!0,this.chainManager.api.tx.ticTacToe.playGame()}async cancelQueue(){if(!this.chainManager.api||!this.accountManager.isConnected())throw new Error("Not connected to chain or wallet");return console.log("Canceling matchmaking..."),this.inQueue=!1,this.chainManager.api.tx.ticTacToe.cancelMatchmaking()}isInQueue(){return this.inQueue}setInQueue(e){this.inQueue=e}}class C{constructor(){this.transactionHistory=[],this.pendingTransactions=new Map,this.timingChart=null}createTransaction(e,t,n,a){return{id:`${e}_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,from:t,to:n,amount:a,status:"pending",statusText:"Signing...",hash:null,blockHash:null,timing:{submitted:Date.now(),ready:null,broadcast:null,inBlock:null,finalized:null,invalid:null}}}addToHistory(e){return this.transactionHistory.unshift(e),this.transactionHistory.length>50&&(this.transactionHistory=this.transactionHistory.slice(0,50)),e.status==="pending"&&e.hash&&this.pendingTransactions.set(e.hash,e),this.transactionHistory}updateInHistory(e,t){const n=this.transactionHistory.find(a=>a.hash===e||a.id===e);return n&&(Object.assign(n,t),t.status!=="pending"&&n.hash&&this.pendingTransactions.delete(n.hash)),this.transactionHistory}clearHistory(){this.transactionHistory=[],this.pendingTransactions.clear()}getHistory(){return this.transactionHistory}getPendingCount(){return this.pendingTransactions.size}calculateStats(){console.log("Calculating stats from",this.transactionHistory.length,"total transactions");const e=[],t=[],n=[];if(this.transactionHistory.forEach(s=>{s.timing.ready&&e.push(s.timing.ready-s.timing.submitted),s.timing.inBlock&&t.push(s.timing.inBlock-s.timing.submitted),s.timing.finalized&&n.push(s.timing.finalized-s.timing.submitted)}),console.log("Stats data:",{ready:e.length,inBlock:t.length,finalized:n.length}),e.length===0&&t.length===0&&n.length===0)return console.log("No timing data available for stats"),null;const a=s=>s.length>0?s.reduce((r,l)=>r+l,0)/s.length:0,i=s=>s.length>0?Math.min(...s):0,o=s=>s.length>0?Math.max(...s):0;return{ready:{min:i(e),max:o(e),avg:a(e),count:e.length},inBlock:{min:i(t),max:o(t),avg:a(t),count:t.length},finalized:{min:i(n),max:o(n),avg:a(n),count:n.length}}}}class v{constructor(e){this.gameManager=e,this.elements=this.cacheElements(),this.gameManager.gameState.onStateChange(t=>{this.updateGameUI(t)})}updateGameUI(e){if(console.log("🎨 updateGameUI called with state:",e.toJSON()),e.gameId===null||e.gameId===void 0){console.log("No game ID, skipping UI update");return}this.updateBoardFromState(e),this.updatePlayerTurnFromState(e),e.isEnded&&(console.log("⏱️ Game ended, hiding timeout section"),this.hideTimeoutSection()),console.log("✅ UI update complete")}updateBoardFromState(e){const t=e.board;console.log("Updating board from state:",t),t.forEach((n,a)=>{const i=document.querySelector(`[data-cell="${a}"]`);if(!i){console.error(`Cell element not found for index ${a}`);return}i.textContent="",i.classList.remove("taken","x","o"),n==="X"?(i.textContent="X",i.classList.add("taken","x")):n==="O"&&(i.textContent="O",i.classList.add("taken","o"))})}updatePlayerTurnFromState(e){console.log("📝 updatePlayerTurnFromState called with:",{playerSymbol:e.playerSymbol,isMyTurn:e.isMyTurn,isActive:e.isActive,isEnded:e.isEnded});const t=this.elements.currentPlayer;if(!t){console.error("❌ Player indicator element not found!");return}if(!e.playerSymbol){console.warn("⚠️ Player symbol not set");return}e.isEnded===!0?t.textContent="Game over":t.textContent=e.isMyTurn?`You are ${e.playerSymbol} - Your turn!`:`You are ${e.playerSymbol} - Opponent's turn...`,t.className=`player-indicator player-${e.playerSymbol.toLowerCase()}`,console.log("✅ Player turn updated successfully")}cacheElements(){return{rpcUrl:document.getElementById("rpcUrl"),connectBtn:document.getElementById("connectBtn"),connectionStatus:document.getElementById("connectionStatus"),statusIndicator:document.getElementById("statusIndicator"),statusText:document.getElementById("statusText"),chainInfo:document.getElementById("chainInfo"),chainName:document.getElementById("chainName"),chainVersion:document.getElementById("chainVersion"),connectWalletBtn:document.getElementById("connectWalletBtn"),useSeedBtn:document.getElementById("useSeedBtn"),seedInput:document.getElementById("seedInput"),seedPhrase:document.getElementById("seedPhrase"),importSeedBtn:document.getElementById("importSeedBtn"),cancelSeedBtn:document.getElementById("cancelSeedBtn"),accountType:document.getElementById("accountType"),accountInfo:document.getElementById("accountInfo"),accountAddress:document.getElementById("accountAddress"),accountBalance:document.getElementById("accountBalance"),playGameBtn:document.getElementById("playGameBtn"),cancelMatchmakingBtn:document.getElementById("cancelMatchmakingBtn"),matchmakingStatus:document.getElementById("matchmakingStatus"),gameBoard:document.getElementById("gameBoard"),gameBoardContainer:document.getElementById("gameBoardContainer"),gameModeSection:document.getElementById("gameModeSection"),gameIdDisplay:document.getElementById("gameIdDisplay"),gameIdValue:document.getElementById("gameIdValue"),playerXAddress:document.getElementById("playerXAddress"),playerOAddress:document.getElementById("playerOAddress"),gameInfoSection:document.getElementById("gameInfoSection"),currentPlayer:document.getElementById("currentPlayer"),gameMessage:document.getElementById("gameMessage"),resetGameBtn:document.getElementById("resetGameBtn"),gameStatsBottom:document.getElementById("gameStatsBottom"),xWins:document.getElementById("xWins"),oWins:document.getElementById("oWins"),draws:document.getElementById("draws"),timeoutSection:document.getElementById("timeoutSection"),timeoutTimer:document.getElementById("timeoutTimer"),timeoutCountdown:document.getElementById("timeoutCountdown"),claimTimeoutBtn:document.getElementById("claimTimeoutBtn"),gameWaitingOverlay:document.getElementById("gameWaitingOverlay"),transactionHistory:document.getElementById("transactionHistory"),clearHistoryBtn:document.getElementById("clearHistoryBtn"),pendingCount:document.getElementById("pendingCount"),timingChart:document.getElementById("timingChart"),statsContent:document.getElementById("statsContent"),minReady:document.getElementById("minReady"),maxReady:document.getElementById("maxReady"),avgReady:document.getElementById("avgReady"),minInBlock:document.getElementById("minInBlock"),maxInBlock:document.getElementById("maxInBlock"),avgInBlock:document.getElementById("avgInBlock"),minFinalized:document.getElementById("minFinalized"),maxFinalized:document.getElementById("maxFinalized"),avgFinalized:document.getElementById("avgFinalized"),blockBanner:document.getElementById("blockBanner"),blockWindow:document.getElementById("blockWindow")}}updateConnectionStatus(e,t){this.elements.statusText.textContent=t,e?this.elements.statusIndicator.classList.add("connected"):this.elements.statusIndicator.classList.remove("connected")}showChainInfo(e,t){this.elements.chainName.textContent=e,this.elements.chainVersion.textContent=t,this.elements.chainInfo.classList.remove("hidden")}hideChainInfo(){this.elements.chainInfo.classList.add("hidden")}showSeedInput(){this.elements.seedInput.classList.remove("hidden")}hideSeedInput(){this.elements.seedInput.classList.add("hidden"),this.elements.seedPhrase.value=""}updateAccountInfo(e,t){this.elements.accountAddress.textContent=e,this.elements.accountType.textContent=t==="seed"?"🔑 Seed Account":"🦊 Extension Account",this.elements.accountInfo.classList.remove("hidden")}updateBalance(e){this.elements.accountBalance.textContent=`Balance: ${e.free} UNIT`}hideAccountInfo(){this.elements.accountInfo.classList.add("hidden")}showMatchmakingWaiting(){this.elements.playGameBtn.classList.add("hidden"),this.elements.cancelMatchmakingBtn.classList.remove("hidden"),this.elements.matchmakingStatus.classList.remove("hidden")}hideMatchmakingWaiting(){this.elements.playGameBtn.classList.remove("hidden"),this.elements.playGameBtn.disabled=!1,this.elements.playGameBtn.textContent="START GAME",this.elements.cancelMatchmakingBtn.classList.add("hidden"),this.elements.matchmakingStatus.classList.add("hidden")}showGameBoard(){this.elements.gameBoardContainer.classList.remove("hidden"),this.elements.gameInfoSection.classList.remove("hidden"),this.elements.gameStatsBottom.classList.remove("hidden"),this.elements.gameModeSection.style.display="none"}hideGameBoard(){this.elements.gameBoardContainer.classList.add("hidden"),this.elements.gameInfoSection.classList.add("hidden"),this.elements.gameStatsBottom.classList.add("hidden"),this.elements.gameIdDisplay.classList.add("hidden"),this.elements.gameModeSection.style.display="block"}updateGameInfo(e,t,n){this.elements.gameIdValue.textContent=e;const a=this.gameManager.accountManager.getAddress(),i=t===a?`YOU (${this.shortenAddress(t)})`:this.shortenAddress(t),o=n===a?`YOU (${this.shortenAddress(n)})`:this.shortenAddress(n);this.elements.playerXAddress.textContent=i,this.elements.playerOAddress.textContent=o,this.elements.gameIdDisplay.classList.remove("hidden")}showGameEndMessage(e,t){this.elements.gameMessage.textContent=e,this.elements.gameMessage.className=`game-message ${t}`,this.elements.gameMessage.classList.remove("hidden")}hideGameMessage(){this.elements.gameMessage.classList.add("hidden")}updateGameStats(e){this.elements.xWins.textContent=e.xWins,this.elements.oWins.textContent=e.oWins,this.elements.draws.textContent=e.draws}showTimeoutSection(){this.elements.timeoutSection.classList.remove("hidden")}hideTimeoutSection(){this.elements.timeoutSection.classList.add("hidden")}updateTimeoutCountdown(e){this.elements.timeoutCountdown.textContent=e}showClaimTimeoutBtn(){this.elements.claimTimeoutBtn.classList.remove("hidden")}hideClaimTimeoutBtn(){this.elements.claimTimeoutBtn.classList.add("hidden")}showGameWaitingOverlay(){this.elements.gameWaitingOverlay&&this.elements.gameWaitingOverlay.classList.remove("hidden")}hideGameWaitingOverlay(){this.elements.gameWaitingOverlay&&this.elements.gameWaitingOverlay.classList.add("hidden")}renderTransactionHistory(e){if(e.length===0){this.elements.transactionHistory.innerHTML='<p class="no-transactions">No transactions yet. Send your first transaction to see it here!</p>';return}this.elements.transactionHistory.innerHTML=e.map(t=>{const n=t.status,a=this.formatTiming(t.timing);return`
                <div class="tx-item ${n}">
                    <div class="tx-header">
                        <div class="tx-status">${t.statusText}</div>
                        <div class="tx-time">${new Date(t.timing.submitted).toLocaleTimeString()}</div>
                    </div>
                    <div class="tx-details">
                        <div><strong>From:</strong> ${this.shortenAddress(t.from)}</div>
                        <div><strong>To:</strong> ${t.to}</div>
                        <div><strong>Action:</strong> ${t.amount}</div>
                        ${t.hash?`<div><strong>Hash:</strong> <span class="tx-hash">${this.shortenHash(t.hash)}</span></div>`:""}
                    </div>
                    ${a?`<div class="tx-timing">${a}</div>`:""}
                </div>
            `}).join("")}updatePendingCount(e){e>0?(this.elements.pendingCount.textContent=`⏳ ${e} pending`,this.elements.pendingCount.classList.remove("hidden")):this.elements.pendingCount.classList.add("hidden")}initializeChart(){if(this.chart){console.log("Chart already initialized");return}if(!this.elements.timingChart){console.error("Chart canvas element not found");return}if(typeof Chart>"u"){console.error("Chart.js library not loaded yet");return}try{console.log("Initializing transaction timing chart...");const e=this.elements.timingChart.getContext("2d");this.chart=new Chart(e,{type:"line",data:{labels:[],datasets:[{label:"Ready",data:[],borderColor:"rgb(75, 192, 192)",backgroundColor:"rgba(75, 192, 192, 0.2)",borderWidth:2,tension:.1,spanGaps:!0},{label:"InBlock",data:[],borderColor:"rgb(255, 159, 64)",backgroundColor:"rgba(255, 159, 64, 0.2)",borderWidth:2,tension:.1,spanGaps:!0},{label:"Finalized",data:[],borderColor:"rgb(153, 102, 255)",backgroundColor:"rgba(153, 102, 255, 0.2)",borderWidth:2,tension:.1,spanGaps:!0}]},options:{responsive:!0,maintainAspectRatio:!0,aspectRatio:2,plugins:{legend:{position:"top",labels:{color:"#c5d9c5"}},title:{display:!0,text:"Transaction Timing (ms)",color:"#c5d9c5"}},scales:{y:{beginAtZero:!0,ticks:{color:"#c5d9c5"},grid:{color:"rgba(197, 217, 197, 0.1)"}},x:{ticks:{color:"#c5d9c5"},grid:{color:"rgba(197, 217, 197, 0.1)"}}}}}),console.log("✅ Chart initialized successfully")}catch(e){console.error("Failed to initialize chart:",e),this.chart=null}}updateChart(e){if(console.log("📊 updateChart called with",e.length,"transactions"),this.chart||(console.log("Chart not initialized, initializing now..."),this.initializeChart()),!this.chart){console.warn("Chart initialization failed, cannot update");return}const t=e.filter(s=>s.timing.ready).slice(0,20).reverse();if(console.log("Found",t.length,"transactions with timing data for chart"),t.length===0){console.log("No transactions with timing data to display"),this.chart.data.labels=[],this.chart.data.datasets[0].data=[],this.chart.data.datasets[1].data=[],this.chart.data.datasets[2].data=[],this.chart.update();return}const n=t.map((s,r)=>`TX ${r+1}`),a=t.map(s=>s.timing.ready?s.timing.ready-s.timing.submitted:null),i=t.map(s=>s.timing.inBlock?s.timing.inBlock-s.timing.submitted:null),o=t.map(s=>s.timing.finalized?s.timing.finalized-s.timing.submitted:null);console.log("Chart data:",{labels:n,ready:a.filter(s=>s!==null).length+" values",inBlock:i.filter(s=>s!==null).length+" values",finalized:o.filter(s=>s!==null).length+" values"}),this.chart.data.labels=n,this.chart.data.datasets[0].data=a,this.chart.data.datasets[1].data=i,this.chart.data.datasets[2].data=o,this.chart.update(),console.log("✅ Chart updated")}updateTransactionStats(e){if(console.log("📈 updateTransactionStats called with:",e),!e){console.log("No stats available, hiding stats section"),this.elements.statsContent.classList.add("hidden");return}this.elements.statsContent.classList.remove("hidden");const t=(n,a)=>a===0?"-":`${Math.round(n)}ms`;this.elements.minReady.textContent=t(e.ready.min,e.ready.count),this.elements.maxReady.textContent=t(e.ready.max,e.ready.count),this.elements.avgReady.textContent=t(e.ready.avg,e.ready.count),this.elements.minInBlock.textContent=t(e.inBlock.min,e.inBlock.count),this.elements.maxInBlock.textContent=t(e.inBlock.max,e.inBlock.count),this.elements.avgInBlock.textContent=t(e.inBlock.avg,e.inBlock.count),this.elements.minFinalized.textContent=t(e.finalized.min,e.finalized.count),this.elements.maxFinalized.textContent=t(e.finalized.max,e.finalized.count),this.elements.avgFinalized.textContent=t(e.finalized.avg,e.finalized.count),console.log("✅ Stats updated:",{ready:e.ready.count,inBlock:e.inBlock.count,finalized:e.finalized.count})}showBlockBanner(){this.elements.blockBanner.classList.remove("hidden")}updateBlockWindow(e,t){this.elements.blockWindow.innerHTML=e.map(n=>`
                <div class="block-item ${n.number<=t?"finalized":""} new-block">
                    <div class="block-number">#${n.number}</div>
                    <div class="block-hash-short">${n.hash.slice(0,8)}...</div>
                </div>
            `).join("")}shortenAddress(e){return e?e.length<16?e:`${e.slice(0,6)}...${e.slice(-6)}`:"-"}shortenHash(e){return e?`${e.slice(0,10)}...${e.slice(-8)}`:"-"}formatTiming(e){const t=[];return e.ready&&t.push(`Ready: ${e.ready-e.submitted}ms`),e.inBlock&&t.push(`InBlock: ${e.inBlock-e.submitted}ms`),e.finalized&&t.push(`Finalized: ${e.finalized-e.submitted}ms`),t.join(" | ")}}class k{constructor(){this.audioContext=null,this.enabled=!0,this.volume=.3,this.initAudioContext()}initAudioContext(){try{this.audioContext=new(window.AudioContext||window.webkitAudioContext)}catch(e){console.error("Web Audio API not supported:",e),this.enabled=!1}}async resume(){this.audioContext&&this.audioContext.state==="suspended"&&await this.audioContext.resume()}playMoveSound(){if(!this.enabled||!this.audioContext)return;const e=this.audioContext.currentTime,t=this.audioContext.createOscillator(),n=this.audioContext.createOscillator(),a=this.audioContext.createGain();t.connect(a),n.connect(a),a.connect(this.audioContext.destination),t.frequency.setValueAtTime(800,e),t.frequency.exponentialRampToValueAtTime(200,e+.1),n.frequency.setValueAtTime(1200,e),n.frequency.exponentialRampToValueAtTime(300,e+.1),t.type="square",n.type="sawtooth",a.gain.setValueAtTime(this.volume*.5,e),a.gain.exponentialRampToValueAtTime(.01,e+.2),t.start(e),n.start(e),t.stop(e+.2),n.stop(e+.2)}playWinSound(){if(!this.enabled||!this.audioContext)return;const e=this.audioContext.currentTime;[220,277,330,440].forEach((t,n)=>{const a=this.audioContext.createOscillator(),i=this.audioContext.createGain(),o=this.audioContext.createBiquadFilter();a.connect(o),o.connect(i),i.connect(this.audioContext.destination),a.frequency.setValueAtTime(t*.5,e),a.frequency.exponentialRampToValueAtTime(t,e+.3),a.type="sawtooth",o.type="lowpass",o.frequency.setValueAtTime(400,e),o.frequency.exponentialRampToValueAtTime(2e3,e+.8);const s=n*.05;i.gain.setValueAtTime(0,e+s),i.gain.linearRampToValueAtTime(this.volume*.4,e+s+.1),i.gain.exponentialRampToValueAtTime(.01,e+s+1.2),a.start(e+s),a.stop(e+s+1.2)})}playLoseSound(){if(!this.enabled||!this.audioContext)return;const e=this.audioContext.currentTime,t=this.audioContext.createOscillator(),n=this.audioContext.createOscillator(),a=this.audioContext.createGain(),i=this.audioContext.createBiquadFilter();t.connect(i),n.connect(i),i.connect(a),a.connect(this.audioContext.destination),t.frequency.setValueAtTime(110,e),t.frequency.exponentialRampToValueAtTime(55,e+1.5),n.frequency.setValueAtTime(165,e),n.frequency.exponentialRampToValueAtTime(82.5,e+1.5),t.type="sawtooth",n.type="triangle",i.type="lowpass",i.frequency.setValueAtTime(800,e),i.frequency.exponentialRampToValueAtTime(100,e+1.5),i.Q.setValueAtTime(5,e),a.gain.setValueAtTime(this.volume*.6,e),a.gain.exponentialRampToValueAtTime(.01,e+1.5),t.start(e),n.start(e),t.stop(e+1.5),n.stop(e+1.5)}playMatchmakingSound(){if(!this.enabled||!this.audioContext)return;const e=this.audioContext.currentTime,t=this.audioContext.sampleRate*.5,n=this.audioContext.createBuffer(1,t,this.audioContext.sampleRate),a=n.getChannelData(0);for(let r=0;r<t;r++)a[r]=Math.random()*2-1;const i=this.audioContext.createBufferSource();i.buffer=n;const o=this.audioContext.createBiquadFilter();o.type="bandpass",o.frequency.setValueAtTime(1e3,e),o.frequency.exponentialRampToValueAtTime(2e3,e+.5),o.Q.setValueAtTime(10,e);const s=this.audioContext.createGain();s.gain.setValueAtTime(this.volume*.3,e),s.gain.exponentialRampToValueAtTime(.01,e+.5),i.connect(o),o.connect(s),s.connect(this.audioContext.destination),i.start(e),i.stop(e+.5)}playTimeoutWarning(){if(!this.enabled||!this.audioContext)return;const e=this.audioContext.currentTime,t=this.audioContext.createOscillator(),n=this.audioContext.createGain();t.connect(n),n.connect(this.audioContext.destination),t.frequency.setValueAtTime(1200,e),t.frequency.exponentialRampToValueAtTime(800,e+.01),t.type="square",n.gain.setValueAtTime(this.volume*.4,e),n.gain.exponentialRampToValueAtTime(.01,e+.05),t.start(e),t.stop(e+.05)}playGameStartSound(){if(!this.enabled||!this.audioContext)return;const e=this.audioContext.currentTime,t=this.audioContext.createOscillator(),n=this.audioContext.createOscillator(),a=this.audioContext.createGain(),i=this.audioContext.createBiquadFilter();t.connect(i),n.connect(i),i.connect(a),a.connect(this.audioContext.destination),t.frequency.setValueAtTime(55,e),n.frequency.setValueAtTime(58,e),t.type="sine",n.type="sine",i.type="lowpass",i.frequency.setValueAtTime(200,e),a.gain.setValueAtTime(0,e),a.gain.linearRampToValueAtTime(this.volume*.5,e+.3),a.gain.exponentialRampToValueAtTime(.01,e+2),t.start(e),n.start(e),t.stop(e+2),n.stop(e+2)}playOpponentTurnSound(){if(!this.enabled||!this.audioContext)return;const e=this.audioContext.currentTime,t=this.audioContext.createOscillator(),n=this.audioContext.createGain(),a=this.audioContext.createBiquadFilter();t.connect(a),a.connect(n),n.connect(this.audioContext.destination),t.frequency.setValueAtTime(440,e),t.frequency.linearRampToValueAtTime(660,e+.05),t.frequency.linearRampToValueAtTime(440,e+.1),t.type="triangle",a.type="highpass",a.frequency.setValueAtTime(300,e),n.gain.setValueAtTime(this.volume*.3,e),n.gain.exponentialRampToValueAtTime(.01,e+.15),t.start(e),t.stop(e+.15)}setVolume(e){this.volume=Math.max(0,Math.min(1,e))}toggleEnabled(){return this.enabled=!this.enabled,this.enabled}isEnabled(){return this.enabled}}class x{constructor(){this.chainManager=new b,this.accountManager=new I(this.chainManager),this.gameManager=new B(this.chainManager,this.accountManager),this.matchmakingManager=new w(this.chainManager,this.accountManager),this.transactionManager=new C,this.uiManager=new v(this.gameManager),this.soundManager=new k,this.timeoutTimer=null,this.timeoutStartTime=null,this.TIMEOUT_SECONDS=60,this.init()}init(){this.setupEventListeners(),this.uiManager.updateGameStats(this.gameManager.gameStats),setTimeout(()=>{this.uiManager.initializeChart()},100),setTimeout(()=>{this.handleConnect()},500)}setupEventListeners(){this.uiManager.elements.connectBtn.addEventListener("click",()=>this.handleConnect()),this.uiManager.elements.connectWalletBtn.addEventListener("click",()=>this.handleConnectWallet()),this.uiManager.elements.useSeedBtn.addEventListener("click",()=>this.uiManager.showSeedInput()),this.uiManager.elements.importSeedBtn.addEventListener("click",()=>this.handleImportSeed()),this.uiManager.elements.cancelSeedBtn.addEventListener("click",()=>this.uiManager.hideSeedInput()),this.uiManager.elements.playGameBtn.addEventListener("click",()=>this.handlePlayGame()),this.uiManager.elements.cancelMatchmakingBtn.addEventListener("click",()=>this.handleCancelMatchmaking()),this.uiManager.elements.resetGameBtn.addEventListener("click",()=>this.handleResetGame()),document.querySelectorAll(".cell").forEach(e=>{e.addEventListener("click",async t=>{await this.soundManager.resume();const n=parseInt(t.target.getAttribute("data-cell"));this.handleCellClick(n)})}),this.uiManager.elements.clearHistoryBtn.addEventListener("click",()=>{this.transactionManager.clearHistory(),this.uiManager.renderTransactionHistory([]),this.uiManager.updatePendingCount(0),this.uiManager.updateChart([]),this.uiManager.updateTransactionStats(null)}),this.uiManager.elements.claimTimeoutBtn.addEventListener("click",()=>this.handleClaimTimeout()),document.getElementById("toggleSoundBtn").addEventListener("click",()=>this.handleToggleSound())}async handleConnect(){const e=this.uiManager.elements.rpcUrl.value.trim(),t=this.uiManager.elements.connectBtn;if(!e){alert("Please enter a valid RPC URL");return}try{t.textContent="Connecting...",t.disabled=!0,this.chainManager.isConnected()&&(console.log("Disconnecting from previous chain..."),await this.handleDisconnect()),await this.chainManager.connect(e);const n=await this.chainManager.getChainInfo();this.uiManager.updateConnectionStatus(!0,"Connected"),this.uiManager.showChainInfo(n.chain,n.version),this.uiManager.showBlockBanner(),await this.chainManager.subscribeToBlocks(async()=>{if(this.accountManager.isConnected())try{const a=await this.accountManager.getBalance();this.uiManager.updateBalance(a)}catch(a){console.error("Error updating balance:",a)}}),this.gameManager.subscribeToGameEvents(async(a,i)=>{await this.handleGameEvent(a,i)}),t.textContent="Connected",t.disabled=!1,this.uiManager.elements.connectWalletBtn.disabled=!1,this.uiManager.elements.connectWalletBtn.classList.remove("disabled")}catch(n){console.error("Connection error:",n),alert(`Failed to connect: ${n.message}`),this.uiManager.updateConnectionStatus(!1,"Disconnected"),t.textContent="Connect",t.disabled=!1}}async handleDisconnect(){console.log("🔌 Disconnecting and resetting state...");try{this.stopTimeoutTimer(),this.chainManager.stopBlockSubscription(),this.accountManager.stopBalanceUpdates(),this.gameManager.resetGame(),this.matchmakingManager.setInQueue(!1),this.transactionManager.clearHistory(),this.chainManager.api&&(await this.chainManager.api.disconnect(),this.chainManager.api=null),this.uiManager.hideGameBoard(),this.uiManager.hideGameMessage(),this.uiManager.hideMatchmakingWaiting(),this.uiManager.hideTimeoutSection(),this.uiManager.hideAccountInfo(),this.uiManager.hideGameWaitingOverlay(),this.uiManager.renderTransactionHistory([]),this.uiManager.updatePendingCount(0),this.uiManager.updateChart([]),this.uiManager.updateTransactionStats(null),this.uiManager.elements.connectWalletBtn.disabled=!0,this.uiManager.elements.connectWalletBtn.classList.add("disabled"),console.log("✅ Disconnected and reset complete")}catch(e){console.error("Error during disconnect:",e)}}async handleConnectWallet(){try{const e=await this.accountManager.connectWallet();this.uiManager.updateAccountInfo(e.address,"extension"),this.accountManager.startBalanceUpdates(n=>{this.uiManager.updateBalance(n)});const t=await this.accountManager.getBalance();this.uiManager.updateBalance(t),await this.checkAndJoinActiveGame()}catch(e){console.error("Wallet connection error:",e),alert(e.message)}}async handleImportSeed(){const e=this.uiManager.elements.seedPhrase.value.trim();if(!e){alert("Please enter a seed string");return}try{const t=await this.accountManager.createFromSeed(e);this.uiManager.hideSeedInput(),this.uiManager.updateAccountInfo(t.address,"seed"),this.accountManager.startBalanceUpdates(a=>{this.uiManager.updateBalance(a)});const n=await this.accountManager.getBalance();this.uiManager.updateBalance(n),await this.checkAndMintFunds(n),await this.checkAndJoinActiveGame()}catch(t){console.error("Seed import error:",t),alert(`Failed to create account: ${t.message}`)}}async handlePlayGame(){if(!this.chainManager.isConnected()||!this.accountManager.isConnected()){alert("Please connect to chain and wallet first");return}const e=this.uiManager.elements.playGameBtn;try{e.disabled=!0,e.textContent="JOINING QUEUE...",this.soundManager.playMatchmakingSound();const t=await this.matchmakingManager.joinQueue(),n=this.transactionManager.createTransaction("matchmaking",this.accountManager.getAddress(),"Matchmaking","Start Game"),a=await this.accountManager.signAndSend(t,async i=>{await this.handleTransactionStatus(i,n,a,o=>{o.type==="PlayerJoinedQueue"?this.uiManager.showMatchmakingWaiting():o.type==="GameCreated"&&(this.uiManager.hideMatchmakingWaiting(),this.matchmakingManager.setInQueue(!1))})})}catch(t){console.error("Matchmaking error:",t),alert(`Failed to join matchmaking: ${t.message}`),e.textContent="START GAME",e.disabled=!1}}async handleCancelMatchmaking(){try{const e=await this.matchmakingManager.cancelQueue(),t=await this.accountManager.signAndSend(e,n=>{n.status.isInBlock&&(this.uiManager.hideMatchmakingWaiting(),t())})}catch(e){console.error("Cancel matchmaking error:",e),alert(`Failed to cancel matchmaking: ${e.message}`)}}async checkAndMintFunds(e){if(!(!this.chainManager.isConnected()||!this.accountManager.isConnected()))try{const t=parseFloat(e);if(isNaN(t)||t===0){console.log("💰 Balance is 0, minting funds...");const n=this.transactionManager.createTransaction("mint_funds",this.accountManager.getAddress(),"Tic-Tac-Toe Pallet","Mint 1000 UNIT"),a=this.chainManager.api.registry.chainDecimals[0]||12,i=1e3*Math.pow(10,a),o=this.chainManager.api.tx.ticTacToe.mintFunds(this.accountManager.currentAccount.address,i),s=await this.accountManager.sendUnsigned(o,async r=>{await this.handleTransactionStatus(r,n,s)})}}catch(t){console.error("Error checking/minting funds:",t)}}async checkAndJoinActiveGame(){if(!(!this.chainManager.isConnected()||!this.accountManager.isConnected()))try{console.log("Checking for active game...");const e=await this.gameManager.getPlayerGame();if(console.log("Game found:",e),!e){console.log("No active game found");return}const[t,n]=e;console.log(`Auto-loading active game #${t}`,n),await this.setupAndShowGame(t,n.player_x.toString(),n.player_o.toString(),n);const a=this.gameManager.getGameInfo();console.log("Game auto-loaded. Active:",a.gameActive,"ID:",a.currentGameId)}catch(e){console.error("Error checking for active game:",e)}}async handleCellClick(e){const t=this.gameManager.getGameInfo();if(console.log("Cell clicked:",e,"Game info:",t),!t.gameActive){console.warn("Game not active!"),alert("Game is not active. Please start a game first.");return}if(t.gameBoard[e]!==null){console.warn("Cell already taken!");return}if(t.currentGameId===null||t.currentGameId===void 0){alert("Please start a game first");return}try{this.uiManager.showGameWaitingOverlay(),this.soundManager.playMoveSound();const n=await this.gameManager.makeMove(e),a=this.transactionManager.createTransaction("game_move",this.accountManager.getAddress(),`Game #${t.currentGameId}`,`Move at [${e}]`),i=await this.accountManager.signAndSend(n,async o=>{await this.handleTransactionStatus(o,a,i),o.status.isInBlock&&this.uiManager.hideGameWaitingOverlay(),o.status.isFinalized&&this.uiManager.hideGameWaitingOverlay()})}catch(n){console.error("Move error:",n),this.uiManager.hideGameWaitingOverlay(),alert(`Failed to make move: ${n.message}`)}}handleResetGame(){this.stopTimeoutTimer(),this.gameManager.resetGame(),this.uiManager.hideGameBoard(),this.uiManager.hideGameMessage(),this.uiManager.hideMatchmakingWaiting(),this.uiManager.hideTimeoutSection(),this.uiManager.updateBoardFromState({board:Array(9).fill(null)})}startTimeoutTimer(){console.log("⏱️ Starting timeout timer (opponent's turn)"),this.stopTimeoutTimer(!1),this.timeoutStartTime=Date.now(),this.uiManager.showTimeoutSection(),this.uiManager.hideClaimTimeoutBtn(),this.timeoutTimer=setInterval(()=>{const e=Math.floor((Date.now()-this.timeoutStartTime)/1e3),t=Math.max(0,this.TIMEOUT_SECONDS-e);this.uiManager.updateTimeoutCountdown(t),t<=10&&t>0&&this.soundManager.playTimeoutWarning(),t===0&&(console.log("⏱️ Timeout expired! Showing claim button"),clearInterval(this.timeoutTimer),this.timeoutTimer=null,this.uiManager.showClaimTimeoutBtn())},1e3)}stopTimeoutTimer(e=!0){this.timeoutTimer&&(console.log("⏱️ Stopping timeout timer (your turn or game ended)"),clearInterval(this.timeoutTimer),this.timeoutTimer=null),this.timeoutStartTime=null,e&&this.uiManager.hideTimeoutSection()}async handleClaimTimeout(){if(this.gameManager.getGameInfo().currentGameId===null||this.gameManager.getGameInfo().currentGameId===void 0){alert("No active game");return}if(confirm("Claim victory due to opponent timeout?"))try{const t=await this.gameManager.claimTimeout(),n=this.transactionManager.createTransaction("claim_timeout",this.accountManager.getAddress(),`Game #${this.gameManager.getGameInfo().currentGameId}`,"Claim Timeout Victory"),a=await this.accountManager.signAndSend(t,async i=>{await this.handleTransactionStatus(i,n,a)});this.stopTimeoutTimer()}catch(t){console.error("Claim timeout error:",t),alert(`Failed to claim timeout: ${t.message}`)}}async handleGameEvent(e,t){switch(await this.gameManager.gameState.handleEvent(e,t),e){case"gameCreated":const n=this.accountManager.getAddress();if((t.playerX===n||t.playerO===n)&&this.matchmakingManager.isInQueue()){console.log("Matched! Loading game..."),this.uiManager.hideMatchmakingWaiting(),this.matchmakingManager.setInQueue(!1),this.soundManager.playGameStartSound();const o=this.gameManager.gameState;o.gameId!==null&&(this.uiManager.showGameBoard(),this.uiManager.updateGameInfo(o.gameId,o.playerX,o.playerO),!o.isMyTurn&&!o.isEnded&&this.startTimeoutTimer())}break;case"moveMade":const a=this.gameManager.gameState;if(a.isEnded){console.log("Game has ended, not starting timeout timer"),this.stopTimeoutTimer();break}a.isMyTurn?(console.log("It's my turn, stopping timeout"),this.stopTimeoutTimer()):(console.log("It's opponent's turn, starting timeout"),this.soundManager.playOpponentTurnSound(),this.startTimeoutTimer());break;case"gameEnded":this.stopTimeoutTimer();const i=this.gameManager.handleGameEnd(t.state);i.winnerType==="winner"?this.soundManager.playWinSound():i.winnerType==="loser"&&this.soundManager.playLoseSound(),this.uiManager.showGameEndMessage(i.message,i.winnerType),this.uiManager.updateGameStats(i.stats);break}}async setupAndShowGame(e,t,n,a=null){try{console.log("Setting up game:",{gameId:e,playerX:t,playerO:n,hasExistingData:!!a});const i=await this.gameManager.setupGame(e,t,n,a);console.log("Setup result:",i),this.uiManager.showGameBoard(),this.uiManager.updateGameInfo(e,t,n);const o=this.gameManager.getGameInfo();if(console.log("Game info:",o),this.uiManager.updateGameStats(o.gameStats),i&&i.ended){this.stopTimeoutTimer();const r=this.gameManager.handleGameEnd(i.state);this.uiManager.showGameEndMessage(r.message,r.winnerType)}else{const r=this.gameManager.gameState;r.isMyTurn?this.stopTimeoutTimer():r.isEnded||this.startTimeoutTimer()}const s=this.gameManager.getGameInfo();console.log("Game setup complete. Final game state:",s),s.gameActive?s.currentGameId===null||s.currentGameId===void 0?(console.error("WARNING: No game ID set after setup!"),console.error("Final state:",s),console.error("Passed game ID:",e),alert("Game setup completed but no game ID. Please try again.")):console.log("✓ Game is ready to play!"):(console.error("WARNING: Game is not active after setup!"),console.error("Final state:",s))}catch(i){console.error("Setup game error:",i),console.error("Stack:",i.stack),alert(`Failed to setup game: ${i.message}`)}}async handleTransactionStatus(e,t,n,a){const{status:i,dispatchError:o}=e;if(i.isInvalid){t.timing.invalid=Date.now(),t.status="error",t.statusText="Invalid",this.updateTransactionUI(t);return}if(e.txHash&&!t.hash&&(t.hash=e.txHash.toHex()),i.isReady&&(t.timing.ready=Date.now(),t.statusText="Ready",this.updateTransactionUI(t)),i.isInBlock){if(t.timing.inBlock=Date.now(),t.status="success",t.statusText="In Block",t.blockHash=i.asInBlock.toHex(),this.updateTransactionUI(t),o){let s="";if(o.isModule){const r=this.chainManager.api.registry.findMetaError(o.asModule);s=`${r.section}.${r.name}`}else s=o.toString();alert(`Transaction failed: ${s}`),n();return}if(a)try{const s=await this.chainManager.api.query.system.events.at(i.asInBlock);for(const{event:r}of s)this.chainManager.api.events.ticTacToe.PlayerJoinedQueue.is(r)&&a({type:"PlayerJoinedQueue"}),this.chainManager.api.events.ticTacToe.GameCreated.is(r)&&a({type:"GameCreated"})}catch(s){console.error("Error reading events:",s)}}i.isFinalized&&(t.timing.finalized=Date.now(),t.statusText="Finalized ✓",t.finalizedBlockHash=i.asFinalized.toHex(),this.updateTransactionUI(t),n())}updateTransactionUI(e){let t;this.transactionManager.getHistory().find(i=>i.id===e.id)?t=this.transactionManager.updateInHistory(e.hash||e.id,e):t=this.transactionManager.addToHistory(e),this.uiManager.renderTransactionHistory(t),this.uiManager.updatePendingCount(this.transactionManager.getPendingCount()),this.uiManager.updateChart(t);const a=this.transactionManager.calculateStats();this.uiManager.updateTransactionStats(a)}handleToggleSound(){const e=this.soundManager.toggleEnabled(),t=document.getElementById("soundOnIcon"),n=document.getElementById("soundOffIcon");e?(t.style.display="block",n.style.display="none",console.log("🔊 Sound enabled")):(t.style.display="none",n.style.display="block",console.log("🔇 Sound disabled"))}}document.addEventListener("DOMContentLoaded",()=>{window.app=new x});
